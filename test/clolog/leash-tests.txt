
(do (initialize-prolog))

(query 'true '((pseudo-fail)) :limit nil :discard-subsumed true)

0. Processing query: ((pseudo-fail))
 1. Entering `pseudo-fail`/0: (pseudo-fail)
 1. Failed `pseudo-fail`/0: (pseudo-fail)
0. Exhausted query: ((pseudo-fail))
[]

(do (initialize-prolog))

(query 'true '() :limit nil :discard-subsumed true)


(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 'true
 '((has-subtype vertebrate mammal))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype vertebrate mammal))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '?x
 '((has-subtype vertebrate ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype vertebrate ?x))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: mammal
 1. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?x:0)
 1. Failed `has-subtype`/2: (has-subtype vertebrate ?x:0)
0. Exhausted query: ((has-subtype vertebrate ?x))
[mammal]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '(has-subtype ?type ?subtype)
 '((has-subtype ?type ?subtype))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype ?type ?subtype))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: (has-subtype vertebrate mammal)
 1. Backtracking into `has-subtype`/2 (2 matching assertions remain): (has-subtype ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: (has-subtype mammal primate)
 1. Backtracking into `has-subtype`/2 (1 matching assertions remain): (has-subtype ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: (has-subtype primate human)
 1. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype ?type:0 ?subtype:0)
 1. Failed `has-subtype`/2: (has-subtype ?type:0 ?subtype:0)
0. Exhausted query: ((has-subtype ?type ?subtype))
[(has-subtype vertebrate mammal)
 (has-subtype mammal primate)
 (has-subtype primate human)]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '(?pred ?type ?subtype)
 '((?pred ?type ?subtype))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((?pred ?type ?subtype))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: (has-subtype vertebrate mammal)
 1. Backtracking into `?pred:0`/2 (2 matching assertions remain): (?pred:0 ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: (has-subtype mammal primate)
 1. Backtracking into `?pred:0`/2 (1 matching assertions remain): (?pred:0 ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: (has-subtype primate human)
 1. Backtracking into `?pred:0`/2 (0 matching assertions remain): (?pred:0 ?type:0 ?subtype:0)
 1. Failed `?pred:0`/2: (?pred:0 ?type:0 ?subtype:0)
0. Exhausted query: ((?pred ?type ?subtype))
[(has-subtype vertebrate mammal)
 (has-subtype mammal primate)
 (has-subtype primate human)]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '(?subtype)
 '((has-subtype mammal ?subtype) (has-subtype ?subtype human))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype mammal ?subtype) (has-subtype ?subtype human))
 1. Entering `has-subtype`/2: (has-subtype mammal primate)
 1. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
 1. Succeeded `has-subtype`/2: (has-subtype mammal primate)
 1. Entering `has-subtype`/2: (has-subtype primate human)
 1. Matched head (has-subtype primate human): (has-subtype primate human)
 1. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: (primate)
 1. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate human)
 1. Failed `has-subtype`/2: (has-subtype primate human)
 1. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:0)
 1. Failed `has-subtype`/2: (has-subtype mammal ?subtype:0)
0. Exhausted query: ((has-subtype mammal ?subtype) (has-subtype ?subtype human))
[(primate)]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `has-subtype*`/2: (has-subtype* mammal primate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal primate)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 false)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `has-subtype*`/2: (has-subtype* mammal primate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal primate)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal primate)
   3. Failed `has-subtype`/2: (has-subtype mammal primate)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal primate)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `has-subtype*`/2: (has-subtype* primate primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate primate)
    4. Entering `has-subtype`/2: (has-subtype primate primate)
    4. Failed `has-subtype`/2: (has-subtype primate primate)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate primate)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
    4. Entering `has-subtype*`/2: (has-subtype* human primate)
    4. Matched head (has-subtype* ?type:4 ?subtype:4): (has-subtype* human primate)
     5. Entering `has-subtype`/2: (has-subtype human primate)
     5. Failed `has-subtype`/2: (has-subtype human primate)
    4. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human primate)
     5. Entering `has-subtype`/2: (has-subtype human ?subtype:4)
     5. Failed `has-subtype`/2: (has-subtype human ?subtype:4)
    4. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human primate)
    4. Failed `has-subtype*`/2: (has-subtype* human primate)
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate primate)
   3. Failed `has-subtype*`/2: (has-subtype* primate primate)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal primate)
  2. Failed `has-subtype*`/2: (has-subtype* mammal primate)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
 1. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* vertebrate primate)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate primate)
0. Exhausted query: ((has-subtype* vertebrate primate))
[true]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 '?x
 '((has-subtype* vertebrate ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate ?x))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate ?x:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: mammal
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?x:0)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?x:0)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* vertebrate ?x:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `has-subtype*`/2: (has-subtype* mammal ?x:0)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal ?x:0)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: primate
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?x:0)
   3. Failed `has-subtype`/2: (has-subtype mammal ?x:0)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal ?x:0)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `has-subtype*`/2: (has-subtype* primate ?x:0)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate ?x:0)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: human
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?x:0)
    4. Failed `has-subtype`/2: (has-subtype primate ?x:0)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate ?x:0)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
    4. Entering `has-subtype*`/2: (has-subtype* human ?x:0)
    4. Matched head (has-subtype* ?type:4 ?subtype:4): (has-subtype* human ?x:0)
     5. Entering `has-subtype`/2: (has-subtype human ?x:0)
     5. Failed `has-subtype`/2: (has-subtype human ?x:0)
    4. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human ?x:0)
     5. Entering `has-subtype`/2: (has-subtype human ?subtype:4)
     5. Failed `has-subtype`/2: (has-subtype human ?subtype:4)
    4. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human ?x:0)
    4. Failed `has-subtype*`/2: (has-subtype* human ?x:0)
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate ?x:0)
   3. Failed `has-subtype*`/2: (has-subtype* primate ?x:0)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal ?x:0)
  2. Failed `has-subtype*`/2: (has-subtype* mammal ?x:0)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
 1. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* vertebrate ?x:0)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
0. Exhausted query: ((has-subtype* vertebrate ?x))
[mammal primate human]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 '[?x ?y]
 '((has-subtype* ?x ?y))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* ?x ?y))
 1. Entering `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* ?x:0 ?y:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: [vertebrate mammal]
  2. Backtracking into `has-subtype`/2 (2 matching assertions remain): (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [mammal primate]
  2. Backtracking into `has-subtype`/2 (1 matching assertions remain): (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [primate human]
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype ?x:0 ?y:0)
  2. Failed `has-subtype`/2: (has-subtype ?x:0 ?y:0)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* ?x:0 ?y:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `has-subtype*`/2: (has-subtype* mammal ?y:0)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal ?y:0)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [vertebrate primate]
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?y:0)
   3. Failed `has-subtype`/2: (has-subtype mammal ?y:0)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal ?y:0)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `has-subtype*`/2: (has-subtype* primate ?y:0)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate ?y:0)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [vertebrate human]
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?y:0)
    4. Failed `has-subtype`/2: (has-subtype primate ?y:0)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate ?y:0)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
    4. Entering `has-subtype*`/2: (has-subtype* human ?y:0)
    4. Matched head (has-subtype* ?type:4 ?subtype:4): (has-subtype* human ?y:0)
     5. Entering `has-subtype`/2: (has-subtype human ?y:0)
     5. Failed `has-subtype`/2: (has-subtype human ?y:0)
    4. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human ?y:0)
     5. Entering `has-subtype`/2: (has-subtype human ?subtype:4)
     5. Failed `has-subtype`/2: (has-subtype human ?subtype:4)
    4. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human ?y:0)
    4. Failed `has-subtype*`/2: (has-subtype* human ?y:0)
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate ?y:0)
   3. Failed `has-subtype*`/2: (has-subtype* primate ?y:0)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal ?y:0)
  2. Failed `has-subtype*`/2: (has-subtype* mammal ?y:0)
  2. Backtracking into `has-subtype`/2 (2 matching assertions remain): (has-subtype ?x:0 ?subtype:1)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
  2. Entering `has-subtype*`/2: (has-subtype* primate ?y:0)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* primate ?y:0)
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [mammal human]
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?y:0)
   3. Failed `has-subtype`/2: (has-subtype primate ?y:0)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate ?y:0)
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
   3. Entering `has-subtype*`/2: (has-subtype* human ?y:0)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* human ?y:0)
    4. Entering `has-subtype`/2: (has-subtype human ?y:0)
    4. Failed `has-subtype`/2: (has-subtype human ?y:0)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human ?y:0)
    4. Entering `has-subtype`/2: (has-subtype human ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype human ?subtype:3)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human ?y:0)
   3. Failed `has-subtype*`/2: (has-subtype* human ?y:0)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype primate ?subtype:2)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate ?y:0)
  2. Failed `has-subtype*`/2: (has-subtype* primate ?y:0)
  2. Backtracking into `has-subtype`/2 (1 matching assertions remain): (has-subtype ?x:0 ?subtype:1)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
  2. Entering `has-subtype*`/2: (has-subtype* human ?y:0)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* human ?y:0)
   3. Entering `has-subtype`/2: (has-subtype human ?y:0)
   3. Failed `has-subtype`/2: (has-subtype human ?y:0)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human ?y:0)
   3. Entering `has-subtype`/2: (has-subtype human ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype human ?subtype:2)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human ?y:0)
  2. Failed `has-subtype*`/2: (has-subtype* human ?y:0)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype ?x:0 ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype ?x:0 ?subtype:1)
 1. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* ?x:0 ?y:0)
 1. Failed `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
0. Exhausted query: ((has-subtype* ?x ?y))
[[vertebrate mammal]
 [mammal primate]
 [primate human]
 [vertebrate primate]
 [vertebrate human]
 [mammal human]]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* vertebrate primate)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  2. Entering `is-type`/1: (is-type primate)
  2. Matched head (is-type primate): (is-type primate)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal primate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal primate)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 false)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* vertebrate primate)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  2. Entering `is-type`/1: (is-type primate)
  2. Matched head (is-type primate): (is-type primate)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal primate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal primate)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal primate)
   3. Failed `has-subtype`/2: (has-subtype mammal primate)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal primate)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate primate)
    4. Entering `has-subtype`/2: (has-subtype primate primate)
    4. Failed `has-subtype`/2: (has-subtype primate primate)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate primate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    3. (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
    3. (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate primate)
   3. Failed `has-subtype*`/2: (has-subtype* primate primate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal primate)
  2. Failed `has-subtype*`/2: (has-subtype* mammal primate)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
  2. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
  2. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type vertebrate)
  2. Failed `is-type`/1: (is-type vertebrate)
 1. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* vertebrate primate)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate primate)
0. Exhausted query: ((has-subtype* vertebrate primate))
[true]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 '?x
 '((has-subtype* vertebrate ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate ?x))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate ?x:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: mammal
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?x:0)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?x:0)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* vertebrate ?x:0)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote vertebrate)))
  1. (truthy?): Failed (truthy? (not= (quote vertebrate) (quote vertebrate)))
  2. Backtracking into `is-type`/1 (3 matching assertions remain): (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal mammal)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal mammal)
   3. Entering `has-subtype`/2: (has-subtype mammal mammal)
   3. Failed `has-subtype`/2: (has-subtype mammal mammal)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote mammal)))
   2. (truthy?): Failed (truthy? (not= (quote mammal) (quote mammal)))
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal mammal)
  2. Failed `has-subtype*`/2: (has-subtype* mammal mammal)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
  2. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Backtracking into `is-type`/1 (2 matching assertions remain): (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal primate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal primate)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: primate
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal primate)
   3. Failed `has-subtype`/2: (has-subtype mammal primate)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal primate)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate primate)
    4. Entering `has-subtype`/2: (has-subtype primate primate)
    4. Failed `has-subtype`/2: (has-subtype primate primate)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate primate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    3. (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
    3. (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate primate)
   3. Failed `has-subtype*`/2: (has-subtype* primate primate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal primate)
  2. Failed `has-subtype*`/2: (has-subtype* mammal primate)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
  2. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Backtracking into `is-type`/1 (1 matching assertions remain): (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote human)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote human)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal human)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal human)
   3. Entering `has-subtype`/2: (has-subtype mammal human)
   3. Failed `has-subtype`/2: (has-subtype mammal human)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal human)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote human)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote human)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate human)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate human)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: human
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate human)
    4. Failed `has-subtype`/2: (has-subtype primate human)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate human)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
    3. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
    3. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
    3. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
    3. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
    4. Entering `has-subtype*`/2: (has-subtype* human human)
    4. Matched head (has-subtype* ?type:4 ?subtype:4): (has-subtype* human human)
     5. Entering `has-subtype`/2: (has-subtype human human)
     5. Failed `has-subtype`/2: (has-subtype human human)
    4. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human human)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     4. (truthy?): Entering (truthy? (not= (quote human) (quote human)))
     4. (truthy?): Failed (truthy? (not= (quote human) (quote human)))
     5. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
     5. Failed `is-type`/1: (is-type human)
     5. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
     5. Failed `is-type`/1: (is-type human)
    4. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human human)
    4. Failed `has-subtype*`/2: (has-subtype* human human)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
    4. Failed `is-type`/1: (is-type human)
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
    4. Failed `is-type`/1: (is-type human)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate human)
   3. Failed `has-subtype*`/2: (has-subtype* primate human)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal human)
  2. Failed `has-subtype*`/2: (has-subtype* mammal human)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
  2. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type ?x:0)
  2. Failed `is-type`/1: (is-type ?x:0)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type vertebrate)
  2. Failed `is-type`/1: (is-type vertebrate)
 1. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* vertebrate ?x:0)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
0. Exhausted query: ((has-subtype* vertebrate ?x))
[mammal primate human]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 '[?x ?y]
 '((has-subtype* ?x ?y))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* ?x ?y))
 1. Entering `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* ?x:0 ?y:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: [vertebrate mammal]
  2. Backtracking into `has-subtype`/2 (2 matching assertions remain): (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [mammal primate]
  2. Backtracking into `has-subtype`/2 (1 matching assertions remain): (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [primate human]
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype ?x:0 ?y:0)
  2. Failed `has-subtype`/2: (has-subtype ?x:0 ?y:0)
 1. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* ?x:0 ?y:0)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote vertebrate)))
  1. (truthy?): Failed (truthy? (not= (quote vertebrate) (quote vertebrate)))
  2. Backtracking into `is-type`/1 (3 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal mammal)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal mammal)
   3. Entering `has-subtype`/2: (has-subtype mammal mammal)
   3. Failed `has-subtype`/2: (has-subtype mammal mammal)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote mammal)))
   2. (truthy?): Failed (truthy? (not= (quote mammal) (quote mammal)))
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal mammal)
  2. Failed `has-subtype*`/2: (has-subtype* mammal mammal)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
  2. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Backtracking into `is-type`/1 (2 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal primate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal primate)
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [vertebrate primate]
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal primate)
   3. Failed `has-subtype`/2: (has-subtype mammal primate)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal primate)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate primate)
    4. Entering `has-subtype`/2: (has-subtype primate primate)
    4. Failed `has-subtype`/2: (has-subtype primate primate)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate primate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    3. (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
    3. (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate primate)
   3. Failed `has-subtype*`/2: (has-subtype* primate primate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal primate)
  2. Failed `has-subtype*`/2: (has-subtype* mammal primate)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
  2. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Backtracking into `is-type`/1 (1 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote human)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote human)))
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Entering `is-type`/1: (is-type mammal)
  2. Matched head (is-type mammal): (is-type mammal)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
  2. Entering `has-subtype*`/2: (has-subtype* mammal human)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* mammal human)
   3. Entering `has-subtype`/2: (has-subtype mammal human)
   3. Failed `has-subtype`/2: (has-subtype mammal human)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* mammal human)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote human)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote human)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   2. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate human)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate human)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [vertebrate human]
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate human)
    4. Failed `has-subtype`/2: (has-subtype primate human)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate human)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
    3. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
    3. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
    3. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
    3. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
    4. Entering `has-subtype*`/2: (has-subtype* human human)
    4. Matched head (has-subtype* ?type:4 ?subtype:4): (has-subtype* human human)
     5. Entering `has-subtype`/2: (has-subtype human human)
     5. Failed `has-subtype`/2: (has-subtype human human)
    4. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human human)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     4. (truthy?): Entering (truthy? (not= (quote human) (quote human)))
     4. (truthy?): Failed (truthy? (not= (quote human) (quote human)))
     5. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
     5. Failed `is-type`/1: (is-type human)
     5. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
     5. Failed `is-type`/1: (is-type human)
    4. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human human)
    4. Failed `has-subtype*`/2: (has-subtype* human human)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
    4. Failed `is-type`/1: (is-type human)
    4. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
    4. Failed `is-type`/1: (is-type human)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate human)
   3. Failed `has-subtype*`/2: (has-subtype* primate human)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* mammal human)
  2. Failed `has-subtype*`/2: (has-subtype* mammal human)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
  2. Failed `is-type`/1: (is-type mammal)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type ?y:0)
  2. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1 (3 matching assertions remain): (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type mammal)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  1. (truthy?): Entering (truthy? (not= (quote mammal) (quote vertebrate)))
  1. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote vertebrate)))
  2. Entering `has-subtype`/2: (has-subtype mammal primate)
  2. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
  2. Entering `is-type`/1: (is-type primate)
  2. Matched head (is-type primate): (is-type primate)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
  2. Entering `has-subtype*`/2: (has-subtype* primate vertebrate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* primate vertebrate)
   3. Entering `has-subtype`/2: (has-subtype primate vertebrate)
   3. Failed `has-subtype`/2: (has-subtype primate vertebrate)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate vertebrate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   3. Entering `is-type`/1: (is-type vertebrate)
   3. Matched head (is-type vertebrate): (is-type vertebrate)
   3. Succeeded `is-type`/1: (is-type vertebrate)
   2. (truthy?): Entering (truthy? (not= (quote primate) (quote vertebrate)))
   2. (truthy?): Succeeded (truthy? (not= (quote primate) (quote vertebrate)))
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   2. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
   2. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
   3. Entering `has-subtype*`/2: (has-subtype* human vertebrate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* human vertebrate)
    4. Entering `has-subtype`/2: (has-subtype human vertebrate)
    4. Failed `has-subtype`/2: (has-subtype human vertebrate)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human vertebrate)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
    4. Entering `is-type`/1: (is-type vertebrate)
    4. Matched head (is-type vertebrate): (is-type vertebrate)
    4. Succeeded `is-type`/1: (is-type vertebrate)
    3. (truthy?): Entering (truthy? (not= (quote human) (quote vertebrate)))
    3. (truthy?): Succeeded (truthy? (not= (quote human) (quote vertebrate)))
    4. Entering `has-subtype`/2: (has-subtype human ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype human ?subtype:3)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type vertebrate)
    4. Failed `is-type`/1: (is-type vertebrate)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
    4. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human vertebrate)
   3. Failed `has-subtype*`/2: (has-subtype* human vertebrate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype primate ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type vertebrate)
   3. Failed `is-type`/1: (is-type vertebrate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate vertebrate)
  2. Failed `has-subtype*`/2: (has-subtype* primate vertebrate)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
  2. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype mammal ?subtype:1)
  2. Backtracking into `is-type`/1 (3 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote mammal) (quote mammal)))
  1. (truthy?): Failed (truthy? (not= (quote mammal) (quote mammal)))
  2. Backtracking into `is-type`/1 (2 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
  2. Entering `has-subtype`/2: (has-subtype mammal primate)
  2. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
  2. Entering `is-type`/1: (is-type primate)
  2. Matched head (is-type primate): (is-type primate)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
  2. Entering `has-subtype*`/2: (has-subtype* primate primate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* primate primate)
   3. Entering `has-subtype`/2: (has-subtype primate primate)
   3. Failed `has-subtype`/2: (has-subtype primate primate)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   2. (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
   2. (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate primate)
  2. Failed `has-subtype*`/2: (has-subtype* primate primate)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
  2. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype mammal ?subtype:1)
  2. Backtracking into `is-type`/1 (1 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote mammal) (quote human)))
  1. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote human)))
  2. Entering `has-subtype`/2: (has-subtype mammal primate)
  2. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
  2. Entering `is-type`/1: (is-type primate)
  2. Matched head (is-type primate): (is-type primate)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
  2. Entering `has-subtype*`/2: (has-subtype* primate human)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* primate human)
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [mammal human]
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate human)
   3. Failed `has-subtype`/2: (has-subtype primate human)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* primate human)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   2. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
   2. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   2. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
   2. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
   3. Entering `has-subtype*`/2: (has-subtype* human human)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* human human)
    4. Entering `has-subtype`/2: (has-subtype human human)
    4. Failed `has-subtype`/2: (has-subtype human human)
   3. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human human)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
    3. (truthy?): Entering (truthy? (not= (quote human) (quote human)))
    3. (truthy?): Failed (truthy? (not= (quote human) (quote human)))
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
    4. Failed `is-type`/1: (is-type human)
    4. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
    4. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human human)
   3. Failed `has-subtype*`/2: (has-subtype* human human)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype primate ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* primate human)
  2. Failed `has-subtype*`/2: (has-subtype* primate human)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type primate)
  2. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype mammal ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype mammal ?subtype:1)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type ?y:0)
  2. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1 (2 matching assertions remain): (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type primate)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  1. (truthy?): Entering (truthy? (not= (quote primate) (quote vertebrate)))
  1. (truthy?): Succeeded (truthy? (not= (quote primate) (quote vertebrate)))
  2. Entering `has-subtype`/2: (has-subtype primate human)
  2. Matched head (has-subtype primate human): (has-subtype primate human)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
  2. Entering `is-type`/1: (is-type human)
  2. Matched head (is-type human): (is-type human)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
  1. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
  2. Entering `has-subtype*`/2: (has-subtype* human vertebrate)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* human vertebrate)
   3. Entering `has-subtype`/2: (has-subtype human vertebrate)
   3. Failed `has-subtype`/2: (has-subtype human vertebrate)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human vertebrate)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   3. Entering `is-type`/1: (is-type vertebrate)
   3. Matched head (is-type vertebrate): (is-type vertebrate)
   3. Succeeded `is-type`/1: (is-type vertebrate)
   2. (truthy?): Entering (truthy? (not= (quote human) (quote vertebrate)))
   2. (truthy?): Succeeded (truthy? (not= (quote human) (quote vertebrate)))
   3. Entering `has-subtype`/2: (has-subtype human ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype human ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type vertebrate)
   3. Failed `is-type`/1: (is-type vertebrate)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human vertebrate)
  2. Failed `has-subtype*`/2: (has-subtype* human vertebrate)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
  2. Failed `is-type`/1: (is-type human)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype primate ?subtype:1)
  2. Backtracking into `is-type`/1 (3 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote primate) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote primate) (quote mammal)))
  2. Entering `has-subtype`/2: (has-subtype primate human)
  2. Matched head (has-subtype primate human): (has-subtype primate human)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
  2. Entering `is-type`/1: (is-type human)
  2. Matched head (is-type human): (is-type human)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
  1. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
  2. Entering `has-subtype*`/2: (has-subtype* human mammal)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* human mammal)
   3. Entering `has-subtype`/2: (has-subtype human mammal)
   3. Failed `has-subtype`/2: (has-subtype human mammal)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human mammal)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   2. (truthy?): Entering (truthy? (not= (quote human) (quote mammal)))
   2. (truthy?): Succeeded (truthy? (not= (quote human) (quote mammal)))
   3. Entering `has-subtype`/2: (has-subtype human ?subtype:2)
   3. Failed `has-subtype`/2: (has-subtype human ?subtype:2)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human mammal)
  2. Failed `has-subtype*`/2: (has-subtype* human mammal)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
  2. Failed `is-type`/1: (is-type human)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype primate ?subtype:1)
  2. Backtracking into `is-type`/1 (2 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
  1. (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
  2. Backtracking into `is-type`/1 (1 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
  1. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
  2. Entering `has-subtype`/2: (has-subtype primate human)
  2. Matched head (has-subtype primate human): (has-subtype primate human)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
  2. Entering `is-type`/1: (is-type human)
  2. Matched head (is-type human): (is-type human)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
  1. (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
  2. Entering `has-subtype*`/2: (has-subtype* human human)
  2. Matched head (has-subtype* ?type:2 ?subtype:2): (has-subtype* human human)
   3. Entering `has-subtype`/2: (has-subtype human human)
   3. Failed `has-subtype`/2: (has-subtype human human)
  2. Backtracking into `has-subtype*`/2 (1 matching assertions remain): (has-subtype* human human)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   2. (truthy?): Entering (truthy? (not= (quote human) (quote human)))
   2. (truthy?): Failed (truthy? (not= (quote human) (quote human)))
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
   3. Failed `is-type`/1: (is-type human)
  2. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* human human)
  2. Failed `has-subtype*`/2: (has-subtype* human human)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type human)
  2. Failed `is-type`/1: (is-type human)
  2. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype primate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype primate ?subtype:1)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type ?y:0)
  2. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1 (1 matching assertions remain): (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type human)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
  1. (truthy?): Entering (truthy? (not= (quote human) (quote vertebrate)))
  1. (truthy?): Succeeded (truthy? (not= (quote human) (quote vertebrate)))
  2. Entering `has-subtype`/2: (has-subtype human ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype human ?subtype:1)
  2. Backtracking into `is-type`/1 (3 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type mammal)
  1. (truthy?): Entering (truthy? (not= (quote human) (quote mammal)))
  1. (truthy?): Succeeded (truthy? (not= (quote human) (quote mammal)))
  2. Entering `has-subtype`/2: (has-subtype human ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype human ?subtype:1)
  2. Backtracking into `is-type`/1 (2 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type primate)
  1. (truthy?): Entering (truthy? (not= (quote human) (quote primate)))
  1. (truthy?): Succeeded (truthy? (not= (quote human) (quote primate)))
  2. Entering `has-subtype`/2: (has-subtype human ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype human ?subtype:1)
  2. Backtracking into `is-type`/1 (1 matching assertions remain): (is-type ?y:0)
  2. Succeeded `is-type`/1: (is-type human)
  1. (truthy?): Entering (truthy? (not= (quote human) (quote human)))
  1. (truthy?): Failed (truthy? (not= (quote human) (quote human)))
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type ?y:0)
  2. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1 (0 matching assertions remain): (is-type ?x:0)
  2. Failed `is-type`/1: (is-type ?x:0)
 1. Backtracking into `has-subtype*`/2 (0 matching assertions remain): (has-subtype* ?x:0 ?y:0)
 1. Failed `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
0. Exhausted query: ((has-subtype* ?x ?y))
[[vertebrate mammal]
 [mammal primate]
 [primate human]
 [vertebrate primate]
 [vertebrate human]
 [mammal human]]

(do (initialize-prolog) (assert<- '((successor 0 (s 0)))))

(query '?x '((successor 0 ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((successor 0 ?x))
 1. Entering `successor`/2: (successor 0 (s 0))
 1. Matched head (successor 0 (s 0)): (successor 0 (s 0))
 1. Succeeded `successor`/2: (successor 0 (s 0))
Recorded answer: (s 0)
 1. Backtracking into `successor`/2 (0 matching assertions remain): (successor 0 ?x:0)
 1. Failed `successor`/2: (successor 0 ?x:0)
0. Exhausted query: ((successor 0 ?x))
[(s 0)]

(do (initialize-prolog) (assert<- '((successor 0 (s 0)))))

(query '?x '((successor ?x (s 0))) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?x (s 0)))
 1. Entering `successor`/2: (successor 0 (s 0))
 1. Matched head (successor 0 (s 0)): (successor 0 (s 0))
 1. Succeeded `successor`/2: (successor 0 (s 0))
Recorded answer: 0
 1. Backtracking into `successor`/2 (0 matching assertions remain): (successor ?x:0 (s 0))
 1. Failed `successor`/2: (successor ?x:0 (s 0))
0. Exhausted query: ((successor ?x (s 0)))
[0]

(do (initialize-prolog) (assert<- '((successor 0 (s 0)))))

(query '?x '((successor ?x (s ?x))) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?x (s ?x)))
 1. Entering `successor`/2: (successor 0 (s 0))
 1. Matched head (successor 0 (s 0)): (successor 0 (s 0))
 1. Succeeded `successor`/2: (successor 0 (s 0))
Recorded answer: 0
 1. Backtracking into `successor`/2 (0 matching assertions remain): (successor ?x:0 (s ?x:0))
 1. Failed `successor`/2: (successor ?x:0 (s ?x:0))
0. Exhausted query: ((successor ?x (s ?x)))
[0]

(do
 (initialize-prolog)
 (assert<- '((successor 0 (s 0))))
 (assert<- '((successor (s ?x) (s (s ?x))))))

(query
 '?x
 '((successor ?x (s (s 0))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((successor ?x (s (s 0))))
 1. Entering `successor`/2: (successor (s 0) (s (s 0)))
 1. Matched head (successor (s ?x:1) (s (s ?x:1))): (successor (s 0) (s (s 0)))
 1. Succeeded `successor`/2: (successor (s 0) (s (s 0)))
Recorded answer: (s 0)
 1. Backtracking into `successor`/2 (0 matching assertions remain): (successor ?x:0 (s (s 0)))
 1. Failed `successor`/2: (successor ?x:0 (s (s 0)))
0. Exhausted query: ((successor ?x (s (s 0))))
[(s 0)]

(do (initialize-prolog) (assert<- '((has-subtype thing ?thing))))

(query
 'true
 '((has-subtype thing mammal))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype thing mammal))
 1. Entering `has-subtype`/2: (has-subtype thing mammal)
 1. Matched head (has-subtype thing ?thing:1): (has-subtype thing mammal)
 1. Succeeded `has-subtype`/2: (has-subtype thing mammal)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((has-subtype thing ?thing))))

(query
 '?bar
 '((has-subtype thing ?bar))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype thing ?bar))
 1. Entering `has-subtype`/2: (has-subtype thing ?bar:0)
 1. Matched head (has-subtype thing ?thing:1): (has-subtype thing ?bar:0)
 1. Succeeded `has-subtype`/2: (has-subtype thing ?bar:0)
Recorded answer: ?bar
 1. Backtracking into `has-subtype`/2 (0 matching assertions remain): (has-subtype thing ?bar:0)
 1. Failed `has-subtype`/2: (has-subtype thing ?bar:0)
0. Exhausted query: ((has-subtype thing ?bar))
[?bar]

(do (initialize-prolog) (assert<- '((successor ?x (s ?x)))))

(query '[?q ?r] '((successor ?q ?r)) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?q ?r))
 1. Entering `successor`/2: (successor ?q:0 (s ?q:0))
 1. Matched head (successor ?x:1 (s ?x:1)): (successor ?q:0 (s ?q:0))
 1. Succeeded `successor`/2: (successor ?q:0 (s ?q:0))
Recorded answer: [?q (s ?q)]
 1. Backtracking into `successor`/2 (0 matching assertions remain): (successor ?q:0 ?r:0)
 1. Failed `successor`/2: (successor ?q:0 ?r:0)
0. Exhausted query: ((successor ?q ?r))
[[?q (s ?q)]]

(do (initialize-prolog) (assert<- '((successor ?x (s ?x)))))

(query '?r '((successor ?q ?r)) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?q ?r))
 1. Entering `successor`/2: (successor ?q:0 (s ?q:0))
 1. Matched head (successor ?x:1 (s ?x:1)): (successor ?q:0 (s ?q:0))
 1. Succeeded `successor`/2: (successor ?q:0 (s ?q:0))
Recorded answer: (s ?q)
 1. Backtracking into `successor`/2 (0 matching assertions remain): (successor ?q:0 ?r:0)
 1. Failed `successor`/2: (successor ?q:0 ?r:0)
0. Exhausted query: ((successor ?q ?r))
[(s ?q)]

(do (initialize-prolog) (assert<- '((pseudo-same ?x ?x))))

(query
 '[?q ?r]
 '((pseudo-same ?q ?r))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((pseudo-same ?q ?r))
 1. Entering `pseudo-same`/2: (pseudo-same ?r:0 ?r:0)
 1. Matched head (pseudo-same ?x:1 ?x:1): (pseudo-same ?r:0 ?r:0)
 1. Succeeded `pseudo-same`/2: (pseudo-same ?r:0 ?r:0)
Recorded answer: [?r ?r]
 1. Backtracking into `pseudo-same`/2 (0 matching assertions remain): (pseudo-same ?q:0 ?r:0)
 1. Failed `pseudo-same`/2: (pseudo-same ?q:0 ?r:0)
0. Exhausted query: ((pseudo-same ?q ?r))
[[?r ?r]]

(do (initialize-prolog) (assert<- '((pseudo-same ?x ?x))))

(query '?x '((pseudo-same ?x ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((pseudo-same ?x ?x))
 1. Entering `pseudo-same`/2: (pseudo-same ?x:0 ?x:0)
 1. Matched head (pseudo-same ?x:1 ?x:1): (pseudo-same ?x:0 ?x:0)
 1. Succeeded `pseudo-same`/2: (pseudo-same ?x:0 ?x:0)
Recorded answer: ?x
 1. Backtracking into `pseudo-same`/2 (0 matching assertions remain): (pseudo-same ?x:0 ?x:0)
 1. Failed `pseudo-same`/2: (pseudo-same ?x:0 ?x:0)
0. Exhausted query: ((pseudo-same ?x ?x))
[?x]

(do (initialize-prolog) (assert<- '((pseudo-same ?x ?x))))

(query '?x '((same ?x ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((same ?x ?x))
 0. (same): Entering (same ?x:0 ?x:0)
 0. (same): Succeeded (same ?x:0 ?x:0)
Recorded answer: ?x
0. Exhausted query: ((same ?x ?x))
[?x]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nibling ?uncle)
    (parent ?nibling ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query '(?x ?y) '((both-male ?x ?y)) :limit nil :discard-subsumed true)

0. Processing query: ((both-male ?x ?y))
 1. Entering `both-male`/2: (both-male ?x:0 ?y:0)
 1. Matched head (both-male ?one:1 ?two:1): (both-male ?x:0 ?y:0)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
Recorded answer: (laban laban)
  2. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  2. Succeeded `male`/1: (male jacob)
Recorded answer: (laban jacob)
  2. Backtracking into `male`/1 (0 matching assertions remain): (male ?y:0)
  2. Failed `male`/1: (male ?y:0)
  2. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  2. Succeeded `male`/1: (male jacob)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
Recorded answer: (jacob laban)
  2. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  2. Succeeded `male`/1: (male jacob)
Recorded answer: (jacob jacob)
  2. Backtracking into `male`/1 (0 matching assertions remain): (male ?y:0)
  2. Failed `male`/1: (male ?y:0)
  2. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  2. Failed `male`/1: (male ?x:0)
 1. Backtracking into `both-male`/2 (0 matching assertions remain): (both-male ?x:0 ?y:0)
 1. Failed `both-male`/2: (both-male ?x:0 ?y:0)
0. Exhausted query: ((both-male ?x ?y))
[(laban laban) (laban jacob) (jacob laban) (jacob jacob)]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nibling ?uncle)
    (parent ?nibling ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query
 '?uncle
 '((uncle jacob ?uncle))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((uncle jacob ?uncle))
 1. Entering `uncle`/2: (uncle jacob ?uncle:0)
 1. Matched head (uncle ?nibling:1 ?uncle:1): (uncle jacob ?uncle:0)
  2. Entering `parent`/2: (parent jacob rebecca)
  2. Matched head (parent jacob rebecca): (parent jacob rebecca)
  2. Succeeded `parent`/2: (parent jacob rebecca)
  2. Entering `sibling`/2: (sibling ?uncle:0 rebecca)
  2. Matched head (sibling ?x:2 ?y:2): (sibling ?uncle:0 rebecca)
   3. Entering `brother`/2: (brother ?uncle:0 rebecca)
   3. Failed `brother`/2: (brother ?uncle:0 rebecca)
  2. Backtracking into `sibling`/2 (1 matching assertions remain): (sibling ?uncle:0 rebecca)
   3. Entering `sister`/2: (sister laban rebecca)
   3. Matched head (sister laban rebecca): (sister laban rebecca)
   3. Succeeded `sister`/2: (sister laban rebecca)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
Recorded answer: laban
  2. Backtracking into `male`/1 (0 matching assertions remain): (male laban)
  2. Failed `male`/1: (male laban)
   3. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?uncle:0 rebecca)
   3. Failed `sister`/2: (sister ?uncle:0 rebecca)
  2. Backtracking into `sibling`/2 (0 matching assertions remain): (sibling ?uncle:0 rebecca)
  2. Failed `sibling`/2: (sibling ?uncle:0 rebecca)
  2. Backtracking into `parent`/2 (0 matching assertions remain): (parent jacob ?parent:1)
  2. Failed `parent`/2: (parent jacob ?parent:1)
 1. Backtracking into `uncle`/2 (0 matching assertions remain): (uncle jacob ?uncle:0)
 1. Failed `uncle`/2: (uncle jacob ?uncle:0)
0. Exhausted query: ((uncle jacob ?uncle))
[laban]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nibling ?uncle)
    (parent ?nibling ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query '[?x ?y] '((sibling ?x ?y)) :limit nil :discard-subsumed true)

0. Processing query: ((sibling ?x ?y))
 1. Entering `sibling`/2: (sibling ?x:0 ?y:0)
 1. Matched head (sibling ?x:1 ?y:1): (sibling ?x:0 ?y:0)
  2. Entering `brother`/2: (brother ?x:0 ?y:0)
  2. Failed `brother`/2: (brother ?x:0 ?y:0)
 1. Backtracking into `sibling`/2 (1 matching assertions remain): (sibling ?x:0 ?y:0)
  2. Entering `sister`/2: (sister laban rebecca)
  2. Matched head (sister laban rebecca): (sister laban rebecca)
  2. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: [laban rebecca]
  2. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?x:0 ?y:0)
  2. Failed `sister`/2: (sister ?x:0 ?y:0)
 1. Backtracking into `sibling`/2 (0 matching assertions remain): (sibling ?x:0 ?y:0)
 1. Failed `sibling`/2: (sibling ?x:0 ?y:0)
0. Exhausted query: ((sibling ?x ?y))
[[laban rebecca]]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nibling ?uncle)
    (parent ?nibling ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query '(?x ?y) '((both-male ?x ?y)) :limit 2 :discard-subsumed true)

0. Processing query: ((both-male ?x ?y))
 1. Entering `both-male`/2: (both-male ?x:0 ?y:0)
 1. Matched head (both-male ?one:1 ?two:1): (both-male ?x:0 ?y:0)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
Recorded answer: (laban laban)
  2. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  2. Succeeded `male`/1: (male jacob)
Recorded answer: (laban jacob)
Answer limit reached.
[(laban laban) (laban jacob)]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nibling ?uncle)
    (parent ?nibling ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query
 '?uncle
 '((sister ?uncle rebecca) (male ?uncle))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((sister ?uncle rebecca) (male ?uncle))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
Recorded answer: laban
 1. Backtracking into `male`/1 (0 matching assertions remain): (male laban)
 1. Failed `male`/1: (male laban)
 1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?uncle:0 rebecca)
 1. Failed `sister`/2: (sister ?uncle:0 rebecca)
0. Exhausted query: ((sister ?uncle rebecca) (male ?uncle))
[laban]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister ?x ?y))))

(query '[?x ?y] '((sister ?x ?y)) :limit nil :discard-subsumed true)

0. Processing query: ((sister ?x ?y))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: [laban rebecca]
 1. Backtracking into `sister`/2 (1 matching assertions remain): (sister ?x:0 ?y:0)
 1. Succeeded `sister`/2: (sister ?x:0 ?y:0)
Recorded subsuming answer (discarded 1 subsumed answer(s)):  [?x ?y]
 1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?x:0 ?y:0)
 1. Failed `sister`/2: (sister ?x:0 ?y:0)
0. Exhausted query: ((sister ?x ?y))
[[?x ?y]]

(do (initialize-prolog) (assert<- '((treasure (buried ?x)))))

(query '?r '((treasure ?r)) :limit nil :discard-subsumed true)

0. Processing query: ((treasure ?r))
 1. Entering `treasure`/1: (treasure (buried ?x:1))
 1. Matched head (treasure (buried ?x:1)): (treasure (buried ?x:1))
 1. Succeeded `treasure`/1: (treasure (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `treasure`/1 (0 matching assertions remain): (treasure ?r:0)
 1. Failed `treasure`/1: (treasure ?r:0)
0. Exhausted query: ((treasure ?r))
[(buried ?unbound-0)]

(do
 (initialize-prolog)
 (assert<- '((treasure (buried ?x))))
 (assert<- '((marks-the-spot X))))

(query
 '[?r ?x]
 '((treasure ?r) (marks-the-spot ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((treasure ?r) (marks-the-spot ?x))
 1. Entering `treasure`/1: (treasure (buried ?x:1))
 1. Matched head (treasure (buried ?x:1)): (treasure (buried ?x:1))
 1. Succeeded `treasure`/1: (treasure (buried ?x:1))
 1. Entering `marks-the-spot`/1: (marks-the-spot X)
 1. Matched head (marks-the-spot X): (marks-the-spot X)
 1. Succeeded `marks-the-spot`/1: (marks-the-spot X)
Recorded answer: [(buried ?unbound-0) X]
 1. Backtracking into `marks-the-spot`/1 (0 matching assertions remain): (marks-the-spot ?x:0)
 1. Failed `marks-the-spot`/1: (marks-the-spot ?x:0)
 1. Backtracking into `treasure`/1 (0 matching assertions remain): (treasure ?r:0)
 1. Failed `treasure`/1: (treasure ?r:0)
0. Exhausted query: ((treasure ?r) (marks-the-spot ?x))
[[(buried ?unbound-0) X]]

(do (initialize-prolog) (assert<- '(("treasure" (buried ?x)))))

(query '?r '(("treasure" ?r)) :limit nil :discard-subsumed true)

0. Processing query: (("treasure" ?r))
 1. Entering `"treasure"`/1: ("treasure" (buried ?x:1))
 1. Matched head ("treasure" (buried ?x:1)): ("treasure" (buried ?x:1))
 1. Succeeded `"treasure"`/1: ("treasure" (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `"treasure"`/1 (0 matching assertions remain): ("treasure" ?r:0)
 1. Failed `"treasure"`/1: ("treasure" ?r:0)
0. Exhausted query: (("treasure" ?r))
[(buried ?unbound-0)]

(do (initialize-prolog) (assert<- '(([treasure] (buried ?x)))))

(query '?r '(([treasure] ?r)) :limit nil :discard-subsumed true)

0. Processing query: (([treasure] ?r))
 1. Entering `[treasure]`/1: ([treasure] (buried ?x:1))
 1. Matched head ([treasure] (buried ?x:1)): ([treasure] (buried ?x:1))
 1. Succeeded `[treasure]`/1: ([treasure] (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `[treasure]`/1 (0 matching assertions remain): ([treasure] ?r:0)
 1. Failed `[treasure]`/1: ([treasure] ?r:0)
0. Exhausted query: (([treasure] ?r))
[(buried ?unbound-0)]

(do (initialize-prolog) (assert<- '(([treasure chest] (buried ?x)))))

(query '?r '(([treasure ?thing] ?r)) :limit nil :discard-subsumed true)

0. Processing query: (([treasure ?thing] ?r))
 1. Entering `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
 1. Matched head ([treasure chest] (buried ?x:1)): ([treasure chest] (buried ?x:1))
 1. Succeeded `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `[treasure ?thing:0]`/1 (0 matching assertions remain): ([treasure ?thing:0] ?r:0)
 1. Failed `[treasure ?thing:0]`/1: ([treasure ?thing:0] ?r:0)
0. Exhausted query: (([treasure ?thing] ?r))
[(buried ?unbound-0)]

(do (initialize-prolog) (assert<- '(([treasure chest] (buried ?x)))))

(query
 '[?r ?thing]
 '(([treasure ?thing] ?r))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: (([treasure ?thing] ?r))
 1. Entering `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
 1. Matched head ([treasure chest] (buried ?x:1)): ([treasure chest] (buried ?x:1))
 1. Succeeded `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
Recorded answer: [(buried ?unbound-0) chest]
 1. Backtracking into `[treasure ?thing:0]`/1 (0 matching assertions remain): ([treasure ?thing:0] ?r:0)
 1. Failed `[treasure ?thing:0]`/1: ([treasure ?thing:0] ?r:0)
0. Exhausted query: (([treasure ?thing] ?r))
[[(buried ?unbound-0) chest]]

(do (initialize-prolog) (assert<- '((male jacob))))

(query '?pred '((?pred jacob)) :limit nil :discard-subsumed true)

0. Processing query: ((?pred jacob))
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Recorded answer: male
 1. Backtracking into `?pred:0`/1 (0 matching assertions remain): (?pred:0 jacob)
 1. Failed `?pred:0`/1: (?pred:0 jacob)
0. Exhausted query: ((?pred jacob))
[male]

(do
 (initialize-prolog)
 (assert<- '((male jacob)))
 (assert<- '((goal (male ?male)))))

(query '?goal '((goal ?goal) ?goal) :limit nil :discard-subsumed true)

0. Processing query: ((goal ?goal) ?goal)
 1. Entering `goal`/1: (goal (male ?male:1))
 1. Matched head (goal (male ?male:1)): (goal (male ?male:1))
 1. Succeeded `goal`/1: (goal (male ?male:1))
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Recorded answer: (male jacob)
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?unbound-0:0)
 1. Failed `male`/1: (male ?unbound-0:0)
 1. Backtracking into `goal`/1 (0 matching assertions remain): (goal ?goal:0)
 1. Failed `goal`/1: (goal ?goal:0)
0. Exhausted query: ((goal ?goal) ?goal)
[(male jacob)]

(do (initialize-prolog) (assert<- '((male jacob))))

(query '?goal '(?goal) :limit nil :discard-subsumed true)

0. Processing query: (?goal)
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Recorded answer: (male jacob)
 1. Backtracking into `[:index 0]`/1 (0 matching assertions remain): ?goal:0
 1. Failed `[:index 0]`/1: ?goal:0
0. Exhausted query: (?goal)
[(male jacob)]

(do (initialize-prolog))

(query 'true '((and)) :limit nil :discard-subsumed true)

0. Processing query: ((and))
 0. (and): Entering (and)
 0. (and): Succeeded (and)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((and (pseudo-fail))) :limit nil :discard-subsumed true)

0. Processing query: ((and (pseudo-fail)))
 0. (and): Entering (and (pseudo-fail))
  1. Entering `pseudo-fail`/0: (pseudo-fail)
  1. Failed `pseudo-fail`/0: (pseudo-fail)
 0. (and): Failed (and (pseudo-fail))
0. Exhausted query: ((and (pseudo-fail)))
[]

(do (initialize-prolog))

(query 'true '((and) (and)) :limit nil :discard-subsumed true)

0. Processing query: ((and) (and))
 0. (and): Entering (and)
 0. (and): Succeeded (and)
 0. (and): Entering (and)
 0. (and): Succeeded (and)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((and (and))) :limit nil :discard-subsumed true)

0. Processing query: ((and (and)))
 0. (and): Entering (and (and))
  0. (and and): Entering (and)
  0. (and and): Succeeded (and)
 0. (and): Succeeded (and (and))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((and (and (and)))) :limit nil :discard-subsumed true)

0. Processing query: ((and (and (and))))
 0. (and): Entering (and (and (and)))
  0. (and and): Entering (and (and))
   0. (and and and): Entering (and)
   0. (and and and): Succeeded (and)
  0. (and and): Succeeded (and (and))
 0. (and): Succeeded (and (and (and)))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query 'true '((and (male ?x))) :limit nil :discard-subsumed true)

0. Processing query: ((and (male ?x)))
 0. (and): Entering (and (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 0. (and): Succeeded (and (male laban))
Recorded answer: true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (and): Failed (and (male ?x:0))
0. Exhausted query: ((and (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query 'true '((and) (male ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((and) (male ?x))
 0. (and): Entering (and)
 0. (and): Succeeded (and)
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
Recorded answer: true
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
 0. (and): Failed (and)
0. Exhausted query: ((and) (male ?x))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((and (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (male ?x)))
 0. (and): Entering (and (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 0. (and): Succeeded (and (male laban) (male laban))
Recorded answer: true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male laban)
  1. Failed `male`/1: (male laban)
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (and): Failed (and (male ?x:0) (male ?x:0))
0. Exhausted query: ((and (male ?x) (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((and (male ?x) (female ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (female ?x)))
 0. (and): Entering (and (male ?x:0) (female ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  1. Entering `female`/1: (female laban)
  1. Failed `female`/1: (female laban)
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (and): Failed (and (male ?x:0) (female ?x:0))
0. Exhausted query: ((and (male ?x) (female ?x)))
[]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((and (male ?x) (and (male ?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (and (male ?x))))
 0. (and): Entering (and (male ?x:0) (and (male ?x:0)))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  0. (and and): Entering (and (male laban))
   1. Entering `male`/1: (male laban)
   1. Matched head (male laban): (male laban)
   1. Succeeded `male`/1: (male laban)
  0. (and and): Succeeded (and (male laban))
 0. (and): Succeeded (and (male laban) (and (male laban)))
Recorded answer: true
   1. Backtracking into `male`/1 (0 matching assertions remain): (male laban)
   1. Failed `male`/1: (male laban)
  0. (and and): Failed (and (male laban))
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (and): Failed (and (male ?x:0) (and (male ?x:0)))
0. Exhausted query: ((and (male ?x) (and (male ?x))))
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 'true
 '((and (male ?x) (male ?y)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (male ?y)))
 0. (and): Entering (and (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 0. (and): Succeeded (and (male laban) (male laban))
Recorded answer: true
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
 0. (and): Succeeded (and (male laban) (male jacob))
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 0. (and): Succeeded (and (male jacob) (male laban))
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
 0. (and): Succeeded (and (male jacob) (male jacob))
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (and): Failed (and (male ?x:0) (male ?y:0))
0. Exhausted query: ((and (male ?x) (male ?y)))
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or)) :limit nil :discard-subsumed true)

0. Processing query: ((or))
 0. (or): Entering (or)
 0. (or): Failed (or)
0. Exhausted query: ((or))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or (pseudo-fail))) :limit nil :discard-subsumed true)

0. Processing query: ((or (pseudo-fail)))
 0. (or): Entering (or (pseudo-fail))
  1. Entering `pseudo-fail`/0: (pseudo-fail)
  1. Failed `pseudo-fail`/0: (pseudo-fail)
 0. (or): Failed (or (pseudo-fail))
0. Exhausted query: ((or (pseudo-fail)))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or (pseudo-succeed))) :limit nil :discard-subsumed true)

0. Processing query: ((or (pseudo-succeed)))
 0. (or): Entering (or (pseudo-succeed))
  1. Entering `pseudo-succeed`/0: (pseudo-succeed)
  1. Matched head (pseudo-succeed): (pseudo-succeed)
  1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((or (pseudo-fail) (pseudo-succeed)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (pseudo-fail) (pseudo-succeed)))
 0. (or): Entering (or (pseudo-fail) (pseudo-succeed))
  1. Entering `pseudo-fail`/0: (pseudo-fail)
  1. Failed `pseudo-fail`/0: (pseudo-fail)
 0. (or): Backtracking into (or (pseudo-fail) (pseudo-succeed))
  1. Entering `pseudo-succeed`/0: (pseudo-succeed)
  1. Matched head (pseudo-succeed): (pseudo-succeed)
  1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((clolog.core/or (pseudo-fail) (pseudo-succeed)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((clolog.core/or (pseudo-fail) (pseudo-succeed)))
 1. Entering `clolog.core/or`/2: (clolog.core/or (pseudo-fail) (pseudo-succeed))
 1. Failed `clolog.core/or`/2: (clolog.core/or (pseudo-fail) (pseudo-succeed))
0. Exhausted query: ((clolog.core/or (pseudo-fail) (pseudo-succeed)))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((clojure.core/or (pseudo-fail) (pseudo-succeed)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((clojure.core/or (pseudo-fail) (pseudo-succeed)))
 1. Entering `clojure.core/or`/2: (clojure.core/or (pseudo-fail) (pseudo-succeed))
 1. Failed `clojure.core/or`/2: (clojure.core/or (pseudo-fail) (pseudo-succeed))
0. Exhausted query: ((clojure.core/or (pseudo-fail) (pseudo-succeed)))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or) (or)) :limit nil :discard-subsumed true)

0. Processing query: ((or) (or))
 0. (or): Entering (or)
 0. (or): Failed (or)
0. Exhausted query: ((or) (or))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((or (or (pseudo-succeed))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (or (pseudo-succeed))))
 0. (or): Entering (or (or (pseudo-succeed)))
  0. (or or): Entering (or (pseudo-succeed))
   1. Entering `pseudo-succeed`/0: (pseudo-succeed)
   1. Matched head (pseudo-succeed): (pseudo-succeed)
   1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((or (or (or (pseudo-succeed)))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (or (or (pseudo-succeed)))))
 0. (or): Entering (or (or (or (pseudo-succeed))))
  0. (or or): Entering (or (or (pseudo-succeed)))
   0. (or or or): Entering (or (pseudo-succeed))
    1. Entering `pseudo-succeed`/0: (pseudo-succeed)
    1. Matched head (pseudo-succeed): (pseudo-succeed)
    1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query 'true '((or (male ?x))) :limit nil :discard-subsumed true)

0. Processing query: ((or (male ?x)))
 0. (or): Entering (or (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Failed (or (male ?x:0))
0. Exhausted query: ((or (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((or (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?x)))
 0. (or): Entering (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Failed (or (male ?x:0) (male ?x:0))
0. Exhausted query: ((or (male ?x) (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((or (male ?x) (or (male ?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (or (male ?x))))
 0. (or): Entering (or (male ?x:0) (or (male ?x:0)))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male ?x:0) (or (male ?x:0)))
  0. (or or): Entering (or (male ?x:0))
   1. Entering `male`/1: (male laban)
   1. Matched head (male laban): (male laban)
   1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): true
   1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
   1. Failed `male`/1: (male ?x:0)
  0. (or or): Failed (or (male ?x:0))
 0. (or): Failed (or (male ?x:0) (or (male ?x:0)))
0. Exhausted query: ((or (male ?x) (or (male ?x))))
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '?x
 '((or (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?x)))
 0. (or): Entering (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: laban
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: jacob
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): laban
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): jacob
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Failed (or (male ?x:0) (male ?x:0))
0. Exhausted query: ((or (male ?x) (male ?x)))
[laban jacob]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '?y
 '((or (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?x)))
 0. (or): Entering (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: ?y
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): ?y
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): ?y
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): ?y
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Failed (or (male ?x:0) (male ?x:0))
0. Exhausted query: ((or (male ?x) (male ?x)))
[?y]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 'true
 '((or (male ?x) (male ?y)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?y)))
 0. (or): Entering (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
 0. (or): Failed (or (male ?x:0) (male ?y:0))
0. Exhausted query: ((or (male ?x) (male ?y)))
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '[?x ?y]
 '((or (male ?x) (male ?y)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?y)))
 0. (or): Entering (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [laban ?y]
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [jacob ?y]
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [?x laban]
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [?x jacob]
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
 0. (or): Failed (or (male ?x:0) (male ?y:0))
0. Exhausted query: ((or (male ?x) (male ?y)))
[[laban ?y] [jacob ?y] [?x laban] [?x jacob]]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '[?x ?y]
 '((or (male ?x) (male ?y) (male ?z)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?y) (male ?z)))
 0. (or): Entering (or (male ?x:0) (male ?y:0) (male ?z:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [laban ?y]
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [jacob ?y]
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male ?x:0) (male ?y:0) (male ?z:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [?x laban]
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [?x jacob]
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
 0. (or): Backtracking into (or (male ?x:0) (male ?y:0) (male ?z:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded subsuming answer (discarded 4 subsumed answer(s)):  [?x ?y]
  1. Backtracking into `male`/1 (1 matching assertions remain): (male ?z:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): [?x ?y]
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?z:0)
  1. Failed `male`/1: (male ?z:0)
 0. (or): Failed (or (male ?x:0) (male ?y:0) (male ?z:0))
0. Exhausted query: ((or (male ?x) (male ?y) (male ?z)))
[[?x ?y]]

(do (initialize-prolog))

(query 'true '((true)) :limit nil :discard-subsumed true)

0. Processing query: ((true))
 0. (true): Entering (true)
 0. (true): Succeeded (true)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '[laban jacob]
 '((male ?x) (true) (male ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (true) (male ?x))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (true): Entering (true)
 0. (true): Succeeded (true)
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
Recorded answer: [laban jacob]
 1. Backtracking into `male`/1 (0 matching assertions remain): (male laban)
 1. Failed `male`/1: (male laban)
 1. Backtracking into `male`/1 (1 matching assertions remain): (male ?x:0)
 1. Succeeded `male`/1: (male jacob)
 0. (true): Entering (true)
 0. (true): Succeeded (true)
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): [laban jacob]
 1. Backtracking into `male`/1 (0 matching assertions remain): (male jacob)
 1. Failed `male`/1: (male jacob)
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (true) (male ?x))
[[laban jacob]]

(do (initialize-prolog))

(query 'true '((false)) :limit nil :discard-subsumed true)

0. Processing query: ((false))
 0. (false): Entering (false)
 0. (false): Failed (false)
0. Exhausted query: ((false))
[]

(do (initialize-prolog))

(query 'true '((truthy? true)) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? true))
 0. (truthy?): Entering (truthy? true)
 0. (truthy?): Succeeded (truthy? true)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((truthy? (+ 1 2))) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? (+ 1 2)))
 0. (truthy?): Entering (truthy? (+ 1 2))
 0. (truthy?): Succeeded (truthy? (+ 1 2))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((truthy? true) (true)) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? true) (true))
 0. (truthy?): Entering (truthy? true)
 0. (truthy?): Succeeded (truthy? true)
 0. (true): Entering (true)
 0. (true): Succeeded (true)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((male ?x) (truthy? (list '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (truthy? (list (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (truthy?): Entering (truthy? (list (quote laban)))
 0. (truthy?): Succeeded (truthy? (list (quote laban)))
Recorded answer: laban
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (truthy? (list (quote ?x))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?y
 '((male ?x) (evals-from? ?y (list '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? ?y (list (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (evals-from?): Entering (evals-from? ?y:0 (list (quote laban)))
 0. (evals-from?): Succeeded (evals-from? (laban) (list (quote laban)))
Recorded answer: (laban)
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? ?y (list (quote ?x))))
[(laban)]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((and (male ?x) (truthy? (list '?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (truthy? (list (quote ?x)))))
 0. (and): Entering (and (male ?x:0) (truthy? (list (quote ?x:0))))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  0. (and truthy?): Entering (truthy? (list (quote laban)))
  0. (and truthy?): Succeeded (truthy? (list (quote laban)))
 0. (and): Succeeded (and (male laban) (truthy? (list (quote laban))))
Recorded answer: laban
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (and): Failed (and (male ?x:0) (truthy? (list (quote ?x:0))))
0. Exhausted query: ((and (male ?x) (truthy? (list (quote ?x)))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((male ?x) (truthy? (= '?x 'laban)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (truthy? (= (quote ?x) (quote laban))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (truthy?): Entering (truthy? (= (quote laban) (quote laban)))
 0. (truthy?): Succeeded (truthy? (= (quote laban) (quote laban)))
Recorded answer: laban
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (truthy? (= (quote ?x) (quote laban))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query '?x '((male ?x) (truthy? nil)) :limit nil :discard-subsumed true)

0. Processing query: ((male ?x) (truthy? nil))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (truthy?): Entering (truthy? nil)
 0. (truthy?): Failed (truthy? nil)
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (truthy? nil))
[]

(do (initialize-prolog) (assert<- '((male laban))))

(query '?x '((truthy? ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? ?x))
 0. (truthy?): Entering (truthy? ?x:0)
 0. (truthy?): Failed, not ground (truthy? ?x:0)
0. Exhausted query: ((truthy? ?x))
[]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((or (male leah) (male ?x) (truthy? (list '?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male leah) (male ?x) (truthy? (list (quote ?x)))))
 0. (or): Entering (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
  1. Entering `male`/1: (male leah)
  1. Failed `male`/1: (male leah)
 0. (or): Backtracking into (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: laban
  1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 0. (or): Backtracking into (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
  0. (or truthy?): Entering (truthy? (list (quote ?x:0)))
  0. (or truthy?): Failed, not ground (truthy? (list (quote ?x:0)))
 0. (or): Failed (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
0. Exhausted query: ((or (male leah) (male ?x) (truthy? (list (quote ?x)))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?message
 '((male ?x) (evals-from? ?message (str "Hello, " '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? ?message (str "Hello, " (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (evals-from?): Entering (evals-from? ?message:0 (str "Hello, " (quote laban)))
 0. (evals-from?): Succeeded (evals-from? "Hello, laban" (str "Hello, " (quote laban)))
Recorded answer: Hello, laban
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? ?message (str "Hello, " (quote ?x))))
["Hello, laban"]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((male ?x) (do (clojure.pprint/cl-format nil "Hello, ~a." '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (do (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (do): Entering (do (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
 0. (do): Succeeded (do (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
Recorded answer: true
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (do (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?message
 '((male ?x)
   (evals-from?
    ?message
    (clojure.pprint/cl-format nil "Hello, ~a." '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? ?message (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (evals-from?): Entering (evals-from? ?message:0 (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
 0. (evals-from?): Succeeded (evals-from? "Hello, laban." (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
Recorded answer: Hello, laban.
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? ?message (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
["Hello, laban."]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?message
 '((male ?x)
   (evals-from?
    [?message]
    [(clojure.pprint/cl-format nil "Hello, ~a." '?x)]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? [?message] [(clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))]))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 0. (evals-from?): Entering (evals-from? [?message:0] [(clojure.pprint/cl-format nil "Hello, ~a." (quote laban))])
 0. (evals-from?): Succeeded (evals-from? ["Hello, laban."] [(clojure.pprint/cl-format nil "Hello, ~a." (quote laban))])
Recorded answer: Hello, laban.
 1. Backtracking into `male`/1 (0 matching assertions remain): (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? [?message] [(clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))]))
["Hello, laban."]

(do (initialize-prolog))

(query
 '[?a ?b]
 '((same [?a 2] [1 ?b]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same [?a 2] [1 ?b]))
 0. (same): Entering (same [?a:0 2] [1 ?b:0])
 0. (same): Succeeded (same [1 2] [1 2])
Recorded answer: [1 2]
0. Exhausted query: ((same [?a 2] [1 ?b]))
[[1 2]]

(do (initialize-prolog))

(query
 '(?a ?b)
 '((same [?a 2] [1 ?b]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same [?a 2] [1 ?b]))
 0. (same): Entering (same [?a:0 2] [1 ?b:0])
 0. (same): Succeeded (same [1 2] [1 2])
Recorded answer: (1 2)
0. Exhausted query: ((same [?a 2] [1 ?b]))
[(1 2)]

(do (initialize-prolog))

(query
 '(?a ?b)
 '((different [?a 2] [1 ?b]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((different [?a 2] [1 ?b]))
 0. (different): Entering (different [?a:0 2] [1 ?b:0])
 0. (different): Failed (different [?a:0 2] [1 ?b:0])
0. Exhausted query: ((different [?a 2] [1 ?b]))
[]

(do (initialize-prolog))

(query 'true '((not (truthy? false))) :limit nil :discard-subsumed true)

0. Processing query: ((not (truthy? false)))
 0. (not): Entering (not (truthy? false))
  0. (not truthy?): Entering (truthy? false)
  0. (not truthy?): Failed (truthy? false)
 0. (not): Succeeded (not (truthy? false))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 'true
 '((not (brother laban rebecca)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((not (brother laban rebecca)))
 0. (not): Entering (not (brother laban rebecca))
  1. Entering `brother`/2: (brother laban rebecca)
  1. Failed `brother`/2: (brother laban rebecca)
 0. (not): Succeeded (not (brother laban rebecca))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((sister laban rebecca))))

(query
 '[?x ?y]
 '((sister ?x ?y) (not (sister ?y ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((sister ?x ?y) (not (sister ?y ?x)))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
 0. (not): Entering (not (sister rebecca laban))
  1. Entering `sister`/2: (sister rebecca laban)
  1. Failed `sister`/2: (sister rebecca laban)
 0. (not): Succeeded (not (sister rebecca laban))
Recorded answer: [laban rebecca]
 1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?x:0 ?y:0)
 1. Failed `sister`/2: (sister ?x:0 ?y:0)
0. Exhausted query: ((sister ?x ?y) (not (sister ?y ?x)))
[[laban rebecca]]

(do (initialize-prolog))

(query
 '?x
 '((and (evals-from? ?x true) (truthy? '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (evals-from? ?x true) (truthy? (quote ?x))))
 0. (and): Entering (and (evals-from? ?x:0 true) (truthy? (quote ?x:0)))
  0. (and evals-from?): Entering (evals-from? ?x:0 true)
  0. (and evals-from?): Succeeded (evals-from? true true)
  0. (and truthy?): Entering (truthy? (quote true))
  0. (and truthy?): Succeeded (truthy? (quote true))
 0. (and): Succeeded (and (evals-from? true true) (truthy? (quote true)))
Recorded answer: true
 0. (and): Failed (and (evals-from? ?x:0 true) (truthy? (quote ?x:0)))
0. Exhausted query: ((and (evals-from? ?x true) (truthy? (quote ?x))))
[true]

(do (initialize-prolog))

(query
 '?x
 '((and (evals-from? ?x true) (truthy? ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (evals-from? ?x true) (truthy? ?x)))
 0. (and): Entering (and (evals-from? ?x:0 true) (truthy? ?x:0))
  0. (and evals-from?): Entering (evals-from? ?x:0 true)
  0. (and evals-from?): Succeeded (evals-from? true true)
  0. (and truthy?): Entering (truthy? true)
  0. (and truthy?): Succeeded (truthy? true)
 0. (and): Succeeded (and (evals-from? true true) (truthy? true))
Recorded answer: true
 0. (and): Failed (and (evals-from? ?x:0 true) (truthy? ?x:0))
0. Exhausted query: ((and (evals-from? ?x true) (truthy? ?x)))
[true]

(do (initialize-prolog))

(query
 'true
 '((if (true) (true) (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (true) (true) (true)))
 0. (if): Entering (if (true) (true) (true))
 0. (if): Checking 'if' condition (if (true) (true) (true))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Taking 'then' branch of (if (true) (true) (true))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Succeeded (if (true) (true) (true))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 'true
 '((if (truthy? true) (true) (false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (truthy? true) (true) (false)))
 0. (if): Entering (if (truthy? true) (true) (false))
 0. (if): Checking 'if' condition (if (truthy? true) (true) (false))
  0. (if truthy?): Entering (truthy? true)
  0. (if truthy?): Succeeded (truthy? true)
 0. (if): Taking 'then' branch of (if (truthy? true) (true) (false))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Succeeded (if (truthy? true) (true) (false))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 '?x
 '((if (true) (evals-from? ?x true) (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (true) (evals-from? ?x true) (evals-from? ?x false)))
 0. (if): Entering (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Checking 'if' condition (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Taking 'then' branch of (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 true)
  0. (if evals-from?): Succeeded (evals-from? true true)
 0. (if): Succeeded (if (true) (evals-from? true true) (evals-from? true false))
Recorded answer: true
 0. (if): Failed (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (true) (evals-from? ?x true) (evals-from? ?x false)))
[true]

(do (initialize-prolog))

(query
 '?x
 '((if (false) (evals-from? ?x true) (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (false) (evals-from? ?x true) (evals-from? ?x false)))
 0. (if): Entering (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Checking 'if' condition (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if false): Entering (false)
  0. (if false): Failed (false)
 0. (if): Taking 'else' branch of (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 false)
  0. (if evals-from?): Succeeded (evals-from? false false)
 0. (if): Succeeded (if (false) (evals-from? false true) (evals-from? false false))
Recorded answer: false
 0. (if): Failed (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (false) (evals-from? ?x true) (evals-from? ?x false)))
[false]

(do (initialize-prolog))

(query
 '?x
 '((if
    (false)
    (evals-from? ?x true)
    (if (false) (evals-from? ?x true) (evals-from? ?x false))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (false) (evals-from? ?x true) (if (false) (evals-from? ?x true) (evals-from? ?x false))))
 0. (if): Entering (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
 0. (if): Checking 'if' condition (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
  0. (if false): Entering (false)
  0. (if false): Failed (false)
 0. (if): Taking 'else' branch of (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
  0. (if if): Entering (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if if): Checking 'if' condition (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
   0. (if if false): Entering (false)
   0. (if if false): Failed (false)
  0. (if if): Taking 'else' branch of (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
   0. (if if evals-from?): Entering (evals-from? ?x:0 false)
   0. (if if evals-from?): Succeeded (evals-from? false false)
  0. (if if): Succeeded (if (false) (evals-from? false true) (evals-from? false false))
 0. (if): Succeeded (if (false) (evals-from? false true) (if (false) (evals-from? false true) (evals-from? false false)))
Recorded answer: false
  0. (if if): Failed (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Failed (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
0. Exhausted query: ((if (false) (evals-from? ?x true) (if (false) (evals-from? ?x true) (evals-from? ?x false))))
[false]

(do (initialize-prolog))

(query
 '?x
 '((if
    (true)
    (if
     (false)
     (evals-from? ?x :inner-then)
     (evals-from? ?x :inner-else))
    (evals-from? ?x :outer-else)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (true) (if (false) (evals-from? ?x :inner-then) (evals-from? ?x :inner-else)) (evals-from? ?x :outer-else)))
 0. (if): Entering (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
 0. (if): Checking 'if' condition (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Taking 'then' branch of (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
  0. (if if): Entering (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
  0. (if if): Checking 'if' condition (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
   0. (if if false): Entering (false)
   0. (if if false): Failed (false)
  0. (if if): Taking 'else' branch of (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
   0. (if if evals-from?): Entering (evals-from? ?x:0 :inner-else)
   0. (if if evals-from?): Succeeded (evals-from? :inner-else :inner-else)
  0. (if if): Succeeded (if (false) (evals-from? :inner-else :inner-then) (evals-from? :inner-else :inner-else))
 0. (if): Succeeded (if (true) (if (false) (evals-from? :inner-else :inner-then) (evals-from? :inner-else :inner-else)) (evals-from? :inner-else :outer-else))
Recorded answer: :inner-else
  0. (if if): Failed (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
 0. (if): Failed (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
0. Exhausted query: ((if (true) (if (false) (evals-from? ?x :inner-then) (evals-from? ?x :inner-else)) (evals-from? ?x :outer-else)))
[:inner-else]

(do (initialize-prolog) (assert<- '((sister laban rebecca))))

(query
 '?x
 '((if
    (sister laban rebecca)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (sister laban rebecca) (evals-from? ?x true) (evals-from? ?x false)))
 0. (if): Entering (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Checking 'if' condition (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 0. (if): Taking 'then' branch of (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 true)
  0. (if evals-from?): Succeeded (evals-from? true true)
 0. (if): Succeeded (if (sister laban rebecca) (evals-from? true true) (evals-from? true false))
Recorded answer: true
  1. Backtracking into `sister`/2 (0 matching assertions remain): (sister laban rebecca)
  1. Failed `sister`/2: (sister laban rebecca)
 0. (if): Failed (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (sister laban rebecca) (evals-from? ?x true) (evals-from? ?x false)))
[true]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister ?x]
 '((if
    (sister ?sibling ?sister)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
 0. (if): Entering (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 0. (if): Taking 'then' branch of (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 true)
  0. (if evals-from?): Succeeded (evals-from? true true)
 0. (if): Succeeded (if (sister laban rebecca) (evals-from? true true) (evals-from? true false))
Recorded answer: [laban rebecca true]
  1. Backtracking into `sister`/2 (1 matching assertions remain): (sister ?sibling:0 ?sister:0)
  1. Succeeded `sister`/2: (sister rachel leah)
 0. (if): Taking 'then' branch of (if (sister rachel leah) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 true)
  0. (if evals-from?): Succeeded (evals-from? true true)
 0. (if): Succeeded (if (sister rachel leah) (evals-from? true true) (evals-from? true false))
Recorded answer: [rachel leah true]
  1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 0. (if): Failed (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
[[laban rebecca true] [rachel leah true]]

(do (initialize-prolog))

(query
 '[?sibling ?sister ?x]
 '((if
    (sister ?sibling ?sister)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
 0. (if): Entering (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  1. Entering `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 0. (if): Taking 'else' branch of (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 false)
  0. (if evals-from?): Succeeded (evals-from? false false)
 0. (if): Succeeded (if (sister ?sibling:0 ?sister:0) (evals-from? false true) (evals-from? false false))
Recorded answer: [?sibling ?sister false]
 0. (if): Failed (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
[[?sibling ?sister false]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((first (sister ?sibling ?sister)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((first (sister ?sibling ?sister)))
 0. (first): Entering first (first (sister ?sibling:0 ?sister:0))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 0. (first): Succeeded, cutting (first (sister laban rebecca))
Recorded answer: [laban rebecca]
 0. (first): Failed (first (sister ?sibling:0 ?sister:0))
0. Exhausted query: ((first (sister ?sibling ?sister)))
[[laban rebecca]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister ?x]
 '((if
    (first (sister ?sibling ?sister))
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (first (sister ?sibling ?sister)) (evals-from? ?x true) (evals-from? ?x false)))
 0. (if): Entering (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Checking 'if' condition (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if first): Entering first (first (sister ?sibling:0 ?sister:0))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
  0. (if first): Succeeded, cutting (first (sister laban rebecca))
 0. (if): Taking 'then' branch of (if (first (sister laban rebecca)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 true)
  0. (if evals-from?): Succeeded (evals-from? true true)
 0. (if): Succeeded (if (first (sister laban rebecca)) (evals-from? true true) (evals-from? true false))
Recorded answer: [laban rebecca true]
  0. (if first): Failed (first (sister ?sibling:0 ?sister:0))
 0. (if): Failed (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (first (sister ?sibling ?sister)) (evals-from? ?x true) (evals-from? ?x false)))
[[laban rebecca true]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((first (and (sister ?sibling ?sister) (sister ?sibling ?sister))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((first (and (sister ?sibling ?sister) (sister ?sibling ?sister))))
 0. (first): Entering first (first (and (sister ?sibling:0 ?sister:0) (sister ?sibling:0 ?sister:0)))
  0. (first and): Entering (and (sister ?sibling:0 ?sister:0) (sister ?sibling:0 ?sister:0))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
  0. (first and): Succeeded (and (sister laban rebecca) (sister laban rebecca))
 0. (first): Succeeded, cutting (first (and (sister laban rebecca) (sister laban rebecca)))
Recorded answer: [laban rebecca]
 0. (first): Failed (first (and (sister ?sibling:0 ?sister:0) (sister ?sibling:0 ?sister:0)))
0. Exhausted query: ((first (and (sister ?sibling ?sister) (sister ?sibling ?sister))))
[[laban rebecca]]

(do (initialize-prolog))

(query 'true '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 0. (var): Entering (var ?x:0)
 0. (var): Succeeded (var ?x:0)
Recorded answer: true
0. Exhausted query: ((var ?x))
[true]

(do (initialize-prolog))

(query 'true '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 0. (var): Entering (var ?x:0)
 0. (var): Succeeded (var ?x:0)
Recorded answer: true
0. Exhausted query: ((var ?x))
[true]

(do (initialize-prolog))

(query '?x '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 0. (var): Entering (var ?x:0)
 0. (var): Succeeded (var ?x:0)
Recorded answer: ?x
0. Exhausted query: ((var ?x))
[?x]

(do (initialize-prolog))

(query '?y '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 0. (var): Entering (var ?x:0)
 0. (var): Succeeded (var ?x:0)
Recorded answer: ?y
0. Exhausted query: ((var ?x))
[?y]

(do (initialize-prolog))

(query 'true '(#'1) :limit nil :discard-subsumed true)

0. Processing query: ((var 1))
 0. (var): Entering (var 1)
 0. (var): Failed (var 1)
0. Exhausted query: ((var 1))
[]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 'true
 '((sister ?_person ?_person))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((sister ?_person ?_person))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: true
 1. Backtracking into `sister`/2 (1 matching assertions remain): (sister ?anon_person-0:0 ?anon_person-1:0)
 1. Succeeded `sister`/2: (sister rachel leah)
Duplicate answer (not recorded): true
 1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?anon_person-0:0 ?anon_person-1:0)
 1. Failed `sister`/2: (sister ?anon_person-0:0 ?anon_person-1:0)
0. Exhausted query: ((sister ?_person ?_person))
[true]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query 'true '((sister ?_ ?_)) :limit nil :discard-subsumed true)

0. Processing query: ((sister ?_ ?_))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: true
 1. Backtracking into `sister`/2 (1 matching assertions remain): (sister ?anon_-0:0 ?anon_-1:0)
 1. Succeeded `sister`/2: (sister rachel leah)
Duplicate answer (not recorded): true
 1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?anon_-0:0 ?anon_-1:0)
 1. Failed `sister`/2: (sister ?anon_-0:0 ?anon_-1:0)
0. Exhausted query: ((sister ?_ ?_))
[true]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query 'true '((sister ? ?)) :limit nil :discard-subsumed true)

0. Processing query: ((sister ? ?))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: true
 1. Backtracking into `sister`/2 (1 matching assertions remain): (sister ?anon-0:0 ?anon-1:0)
 1. Succeeded `sister`/2: (sister rachel leah)
Duplicate answer (not recorded): true
 1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?anon-0:0 ?anon-1:0)
 1. Failed `sister`/2: (sister ?anon-0:0 ?anon-1:0)
0. Exhausted query: ((sister ? ?))
[true]

(do (initialize-prolog))

(query
 '?x
 '((and
    (if (true) (same ?x :succeed) (same ?x :fail))
    (evals-from? ?x :succeed)
    (false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (if (true) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :succeed) (false)))
 0. (and): Entering (and (if (true) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :succeed) (false))
  0. (and if): Entering (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
  0. (and if): Checking 'if' condition (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
   0. (and if true): Entering (true)
   0. (and if true): Succeeded (true)
  0. (and if): Taking 'then' branch of (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
   0. (and if same): Entering (same ?x:0 :succeed)
   0. (and if same): Succeeded (same :succeed :succeed)
  0. (and if): Succeeded (if (true) (same :succeed :succeed) (same :succeed :fail))
  0. (and evals-from?): Entering (evals-from? :succeed :succeed)
  0. (and evals-from?): Succeeded (evals-from? :succeed :succeed)
  0. (and false): Entering (false)
  0. (and false): Failed (false)
  0. (and if): Failed (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
 0. (and): Failed (and (if (true) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :succeed) (false))
0. Exhausted query: ((and (if (true) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :succeed) (false)))
[]

(do (initialize-prolog))

(query
 '?x
 '((and
    (if (false) (same ?x :succeed) (same ?x :fail))
    (evals-from? ?x :fail)
    (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (true)))
 0. (and): Entering (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (true))
  0. (and if): Entering (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
  0. (and if): Checking 'if' condition (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   0. (and if false): Entering (false)
   0. (and if false): Failed (false)
  0. (and if): Taking 'else' branch of (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   0. (and if same): Entering (same ?x:0 :fail)
   0. (and if same): Succeeded (same :fail :fail)
  0. (and if): Succeeded (if (false) (same :fail :succeed) (same :fail :fail))
  0. (and evals-from?): Entering (evals-from? :fail :fail)
  0. (and evals-from?): Succeeded (evals-from? :fail :fail)
  0. (and true): Entering (true)
  0. (and true): Succeeded (true)
 0. (and): Succeeded (and (if (false) (same :fail :succeed) (same :fail :fail)) (evals-from? :fail :fail) (true))
Recorded answer: :fail
  0. (and if): Failed (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
 0. (and): Failed (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (true))
0. Exhausted query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (true)))
[:fail]

(do (initialize-prolog))

(query
 '?x
 '((and
    (if (false) (same ?x :succeed) (same ?x :fail))
    (evals-from? ?x :fail)
    (or (true) (false))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (or (true) (false))))
 0. (and): Entering (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (or (true) (false)))
  0. (and if): Entering (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
  0. (and if): Checking 'if' condition (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   0. (and if false): Entering (false)
   0. (and if false): Failed (false)
  0. (and if): Taking 'else' branch of (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   0. (and if same): Entering (same ?x:0 :fail)
   0. (and if same): Succeeded (same :fail :fail)
  0. (and if): Succeeded (if (false) (same :fail :succeed) (same :fail :fail))
  0. (and evals-from?): Entering (evals-from? :fail :fail)
  0. (and evals-from?): Succeeded (evals-from? :fail :fail)
  0. (and or): Entering (or (true) (false))
  0. (and or): Succeeded (or (true) (false))
   0. (and or true): Entering (true)
   0. (and or true): Succeeded (true)
 0. (and): Succeeded (and (if (false) (same :fail :succeed) (same :fail :fail)) (evals-from? :fail :fail) (or (true) (false)))
Recorded answer: :fail
  0. (and or): Backtracking into (or (true) (false))
   0. (and or false): Entering (false)
   0. (and or false): Failed (false)
  0. (and or): Failed (or (true) (false))
  0. (and if): Failed (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
 0. (and): Failed (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (or (true) (false)))
0. Exhausted query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (or (true) (false))))
[:fail]

(do (initialize-prolog))

(query
 '?x
 '((and) (evals-from? ?x :fail) (true))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and) (evals-from? ?x :fail) (true))
 0. (and): Entering (and)
 0. (and): Succeeded (and)
 0. (evals-from?): Entering (evals-from? ?x:0 :fail)
 0. (evals-from?): Succeeded (evals-from? :fail :fail)
 0. (true): Entering (true)
 0. (true): Succeeded (true)
Recorded answer: :fail
 0. (and): Failed (and)
0. Exhausted query: ((and) (evals-from? ?x :fail) (true))
[:fail]

(do (initialize-prolog))

(query
 '?x
 '((and (and) (evals-from? ?x :fail) (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (and) (evals-from? ?x :fail) (true)))
 0. (and): Entering (and (and) (evals-from? ?x:0 :fail) (true))
  0. (and and): Entering (and)
  0. (and and): Succeeded (and)
  0. (and evals-from?): Entering (evals-from? ?x:0 :fail)
  0. (and evals-from?): Succeeded (evals-from? :fail :fail)
  0. (and true): Entering (true)
  0. (and true): Succeeded (true)
 0. (and): Succeeded (and (and) (evals-from? :fail :fail) (true))
Recorded answer: :fail
  0. (and and): Failed (and)
 0. (and): Failed (and (and) (evals-from? ?x:0 :fail) (true))
0. Exhausted query: ((and (and) (evals-from? ?x :fail) (true)))
[:fail]

(do (initialize-prolog))

(query 'true '((cond*)) :limit nil :discard-subsumed true)

0. Processing query: ((cond*))
 1. (cond*): Applying logic transform (cond*)
 0. (or): Entering (or)
 0. (or): Failed (or)
0. Exhausted query: ((cond*))
[]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister ?x]
 '((if%
    (sister ?sibling ?sister)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if% (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
 1. (if%): Applying logic transform (if% ?if ?then ?else)
 0. (if): Entering (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 0. (if): Checking 'if' condition (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if first): Entering first (first (sister ?sibling:0 ?sister:0))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
  0. (if first): Succeeded, cutting (first (sister laban rebecca))
 0. (if): Taking 'then' branch of (if (first (sister laban rebecca)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  0. (if evals-from?): Entering (evals-from? ?x:0 true)
  0. (if evals-from?): Succeeded (evals-from? true true)
 0. (if): Succeeded (if (first (sister laban rebecca)) (evals-from? true true) (evals-from? true false))
Recorded answer: [laban rebecca true]
  0. (if first): Failed (first (sister ?sibling:0 ?sister:0))
 0. (if): Failed (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if% (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
[[laban rebecca true]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?x]
 '((cond%
    (sister ?sibling adam)
    (evals-from? ?x 'adam)
    (sister ?sibling eve)
    (evals-from? ?x 'eve)
    :else
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((cond% (sister ?sibling adam) (evals-from? ?x (quote adam)) (sister ?sibling eve) (evals-from? ?x (quote eve)) :else (evals-from? ?x false)))
 1. (cond%): Applying logic transform (cond% ?if1 ?then1 ?if2 ?then2 ?rest)
 1. (if%): Applying logic transform (if% ?if ?then ?else)
 0. (if): Entering (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
 0. (if): Checking 'if' condition (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
  0. (if first): Entering first (first (sister ?sibling:0 adam))
   1. Entering `sister`/2: (sister ?sibling:0 adam)
   1. Failed `sister`/2: (sister ?sibling:0 adam)
  0. (if first): Failed (first (sister ?sibling:0 adam))
 0. (if): Taking 'else' branch of (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
  1. (if cond%): Applying logic transform (cond% ?if ?then :else ?else)
  1. (if if%): Applying logic transform (if% ?if ?then ?else)
  0. (if if): Entering (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
  0. (if if): Checking 'if' condition (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
   0. (if if first): Entering first (first (sister ?sibling:0 eve))
    1. Entering `sister`/2: (sister ?sibling:0 eve)
    1. Failed `sister`/2: (sister ?sibling:0 eve)
   0. (if if first): Failed (first (sister ?sibling:0 eve))
  0. (if if): Taking 'else' branch of (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
   0. (if if evals-from?): Entering (evals-from? ?x:0 false)
   0. (if if evals-from?): Succeeded (evals-from? false false)
  0. (if if): Succeeded (if (first (sister ?sibling:0 eve)) (evals-from? false (quote eve)) (evals-from? false false))
 0. (if): Succeeded (if (first (sister ?sibling:0 adam)) (evals-from? false (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? false (quote eve)) :else (evals-from? false false)))
Recorded answer: [?sibling false]
  0. (if if): Failed (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
 0. (if): Failed (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
0. Exhausted query: ((cond% (sister ?sibling adam) (evals-from? ?x (quote adam)) (sister ?sibling eve) (evals-from? ?x (quote eve)) :else (evals-from? ?x false)))
[[?sibling false]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((or (sister ?sibling ?sister) (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (sister ?sibling ?sister) (true)))
 0. (or): Entering (or (sister ?sibling:0 ?sister:0) (true))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: [laban rebecca]
  1. Backtracking into `sister`/2 (1 matching assertions remain): (sister ?sibling:0 ?sister:0)
  1. Succeeded `sister`/2: (sister rachel leah)
Recorded answer: [rachel leah]
  1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 0. (or): Backtracking into (or (sister ?sibling:0 ?sister:0) (true))
  0. (or true): Entering (true)
  0. (or true): Succeeded (true)
Recorded subsuming answer (discarded 2 subsumed answer(s)):  [?sibling ?sister]
 0. (or): Failed (or (sister ?sibling:0 ?sister:0) (true))
0. Exhausted query: ((or (sister ?sibling ?sister) (true)))
[[?sibling ?sister]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((first (or (sister ?sibling ?sister) (true))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((first (or (sister ?sibling ?sister) (true))))
 0. (first): Entering first (first (or (sister ?sibling:0 ?sister:0) (true)))
  0. (first or): Entering (or (sister ?sibling:0 ?sister:0) (true))
  0. (first or): Succeeded (or (sister ?sibling:0 ?sister:0) (true))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
 0. (first): Succeeded, cutting (first (or (sister laban rebecca) (true)))
Recorded answer: [laban rebecca]
 0. (first): Failed (first (or (sister ?sibling:0 ?sister:0) (true)))
0. Exhausted query: ((first (or (sister ?sibling ?sister) (true))))
[[laban rebecca]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((optional (sister ?sibling ?sister)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((optional (sister ?sibling ?sister)))
 1. (optional): Applying logic transform (optional ?goal)
 0. (if): Entering (if (sister ?sibling:0 ?sister:0) (true) (true))
 0. (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (true) (true))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 0. (if): Taking 'then' branch of (if (sister laban rebecca) (true) (true))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Succeeded (if (sister laban rebecca) (true) (true))
Recorded answer: [laban rebecca]
  1. Backtracking into `sister`/2 (1 matching assertions remain): (sister ?sibling:0 ?sister:0)
  1. Succeeded `sister`/2: (sister rachel leah)
 0. (if): Taking 'then' branch of (if (sister rachel leah) (true) (true))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Succeeded (if (sister rachel leah) (true) (true))
Recorded answer: [rachel leah]
  1. Backtracking into `sister`/2 (0 matching assertions remain): (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 0. (if): Failed (if (sister ?sibling:0 ?sister:0) (true) (true))
0. Exhausted query: ((optional (sister ?sibling ?sister)))
[[laban rebecca] [rachel leah]]

(do
 (initialize-prolog)
 (assert<- '((if% ?if ?then ?else) (if (first ?if) ?then ?else)))
 (assert<- '((cond*) (or)))
 (assert<- '((cond* ?if ?then :else ?else) (if* ?if ?then ?else)))
 (assert<-
  '((cond* ?if1 ?then1 ?if2 ?then2 & ?rest)
    (if* ?if1 ?then1 (cond* ?if2 ?then2 & ?rest))))
 (assert<- '((lisp ?form) (do ?form)))
 (assert<- '((lisp ?logic ?form) (evals-from? ?logic ?form)))
 (assert<- '((is ?a ?b) (same ?a ?b)))
 (assert<- '((if* ?if ?then ?else) (if ?if ?then ?else)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah)))
 (assert<- '((cond%) (or)))
 (assert<- '((cond% ?if ?then :else ?else) (if% ?if ?then ?else)))
 (assert<-
  '((cond% ?if1 ?then1 ?if2 ?then2 & ?rest)
    (if% ?if1 ?then1 (cond% ?if2 ?then2 & ?rest))))
 (assert<- '((lispp ?form) (truthy? ?form)))
 (assert<- '((optional ?goal) (if ?goal (true) (true)))))

(query
 '[?sibling ?x]
 '((cond%
    (sister ?sibling adam)
    (evals-from? ?x 'adam)
    (sister ?sibling eve)
    (evals-from? ?x 'eve)
    :else
    (evals-from? ?x false)))
 :limit
 1
 :discard-subsumed
 true)

0. Processing query: ((cond% (sister ?sibling adam) (evals-from? ?x (quote adam)) (sister ?sibling eve) (evals-from? ?x (quote eve)) :else (evals-from? ?x false)))
 1. Entering `cond%`/6: (cond% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
 1. Matched head (cond% ?if1:1 ?then1:1 ?if2:1 ?then2:1 & ?rest:1): (cond% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
  2. Entering `if%`/3: (if% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
  2. Matched head (if% ?if:1 ?then:1 ?else:1): (if% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
   2. (if): Entering (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
   2. (if): Checking 'if' condition (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
    2. (if first): Entering first (first (sister ?sibling:0 adam))
     3. Entering `sister`/2: (sister ?sibling:0 adam)
     3. Failed `sister`/2: (sister ?sibling:0 adam)
    2. (if first): Failed (first (sister ?sibling:0 adam))
   2. (if): Taking 'else' branch of (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
    3. Entering `cond%`/4: (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
    3. Matched head (cond% ?if:3 ?then:3 :else ?else:3): (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
     4. Entering `if%`/3: (if% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
     4. Matched head (if% ?if:3 ?then:3 ?else:3): (if% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
      4. (if if): Entering (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
      4. (if if): Checking 'if' condition (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
       4. (if if first): Entering first (first (sister ?sibling:0 eve))
        5. Entering `sister`/2: (sister ?sibling:0 eve)
        5. Failed `sister`/2: (sister ?sibling:0 eve)
       4. (if if first): Failed (first (sister ?sibling:0 eve))
      4. (if if): Taking 'else' branch of (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
       4. (if if evals-from?): Entering (evals-from? ?x:0 false)
       4. (if if evals-from?): Succeeded (evals-from? false false)
      4. (if if): Succeeded (if (first (sister ?sibling:0 eve)) (evals-from? false (quote eve)) (evals-from? false false))
     4. (if): Succeeded (if (first (sister ?sibling:0 adam)) (evals-from? false (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? false (quote eve)) :else (evals-from? false false)))
Recorded answer: [?sibling false]
Answer limit reached.
[[?sibling false]]

(do (initialize-prolog))

(query 'true '((ground [a b])) :limit nil :discard-subsumed true)

0. Processing query: ((ground [a b]))
 0. (ground): Entering (ground [a b])
 0. (ground): Succeeded (ground [a b])
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((ground [a b])) :limit nil :discard-subsumed true)

0. Processing query: ((ground [a b]))
 0. (ground): Entering (ground [a b])
 0. (ground): Succeeded (ground [a b])
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((ground ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((ground ?x))
 0. (ground): Entering (ground ?x:0)
 0. (ground): Failed (ground ?x:0)
0. Exhausted query: ((ground ?x))
[]

(do (initialize-prolog))

(query '?x '((same ?x 1) (ground ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((same ?x 1) (ground ?x))
 0. (same): Entering (same ?x:0 1)
 0. (same): Succeeded (same 1 1)
 0. (ground): Entering (ground 1)
 0. (ground): Succeeded (ground 1)
Recorded answer: 1
0. Exhausted query: ((same ?x 1) (ground ?x))
[1]

(do (initialize-prolog))

(query
 '[?sibling ?sister]
 '((optional (sister ?sibling ?sister)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((optional (sister ?sibling ?sister)))
 1. (optional): Applying logic transform (optional ?goal)
 0. (if): Entering (if (sister ?sibling:0 ?sister:0) (true) (true))
 0. (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (true) (true))
  1. Entering `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 0. (if): Taking 'else' branch of (if (sister ?sibling:0 ?sister:0) (true) (true))
  0. (if true): Entering (true)
  0. (if true): Succeeded (true)
 0. (if): Succeeded (if (sister ?sibling:0 ?sister:0) (true) (true))
Recorded answer: [?sibling ?sister]
 0. (if): Failed (if (sister ?sibling:0 ?sister:0) (true) (true))
0. Exhausted query: ((optional (sister ?sibling ?sister)))
[[?sibling ?sister]]

(do (initialize-prolog))

(query 'true '((different 1 2)) :limit nil :discard-subsumed true)

0. Processing query: ((different 1 2))
 0. (different): Entering (different 1 2)
 0. (different): Succeeded (different 1 2)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((different 2 2)) :limit nil :discard-subsumed true)

0. Processing query: ((different 2 2))
 0. (different): Entering (different 2 2)
 0. (different): Failed (different 2 2)
0. Exhausted query: ((different 2 2))
[]

(do (initialize-prolog))

(query
 'true
 '((same (->? (+ 0 1)) 1))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same (->? (+ 0 1)) 1))
 Applied ->? transform
 0. (evals-from?): Entering (evals-from? ??-0:0 (+ 0 1))
 0. (evals-from?): Succeeded (evals-from? 1 (+ 0 1))
 0. (same): Entering (same 1 1)
 0. (same): Succeeded (same 1 1)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 '[1 2 & ?rest]
 '((same ?rest [3 4]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same ?rest [3 4]))
 0. (same): Entering (same ?rest:0 [3 4])
 0. (same): Succeeded (same [3 4] [3 4])
Recorded answer: [1 2 3 4]
0. Exhausted query: ((same ?rest [3 4]))
[[1 2 3 4]]

(do
 (initialize-prolog)
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query '?rest '((variadic & ?rest)) :limit nil :discard-subsumed true)

0. Processing query: ((variadic & ?rest))
 1. Entering `variadic`/1: (variadic 1)
 1. Matched head (variadic 1): (variadic 1)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (1)
 1. Backtracking into `variadic`/2 (1 matching assertions remain): (variadic & ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (1 2)
 1. Backtracking into `variadic`/2 (0 matching assertions remain): (variadic & ?rest:0)
 1. Failed `variadic`/2: (variadic & ?rest:0)
0. Exhausted query: ((variadic & ?rest))
[(1) (1 2)]

(do
 (initialize-prolog)
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query
 '(variadic & ?rest)
 '((variadic & ?rest))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic & ?rest))
 1. Entering `variadic`/1: (variadic 1)
 1. Matched head (variadic 1): (variadic 1)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (variadic 1)
 1. Backtracking into `variadic`/2 (1 matching assertions remain): (variadic & ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (variadic 1 2)
 1. Backtracking into `variadic`/2 (0 matching assertions remain): (variadic & ?rest:0)
 1. Failed `variadic`/2: (variadic & ?rest:0)
0. Exhausted query: ((variadic & ?rest))
[(variadic 1) (variadic 1 2)]

(do
 (initialize-prolog)
 (assert<- '((variadic-term [1])))
 (assert<- '((variadic-term [1 2]))))

(query
 '?rest
 '((variadic-term [& ?rest]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic-term [& ?rest]))
 1. Entering `variadic-term`/1: (variadic-term [1])
 1. Matched head (variadic-term [1]): (variadic-term [1])
 1. Succeeded `variadic-term`/1: (variadic-term [1])
Recorded answer: [1]
 1. Backtracking into `variadic-term`/1 (1 matching assertions remain): (variadic-term [& ?rest:0])
 1. Succeeded `variadic-term`/1: (variadic-term [1 2])
Recorded answer: [1 2]
 1. Backtracking into `variadic-term`/1 (0 matching assertions remain): (variadic-term [& ?rest:0])
 1. Failed `variadic-term`/1: (variadic-term [& ?rest:0])
0. Exhausted query: ((variadic-term [& ?rest]))
[[1] [1 2]]

(do
 (initialize-prolog)
 (assert<- '((variadic-term [1])))
 (assert<- '((variadic-term [1 2]))))

(query
 '?rest
 '((variadic-term [1 & ?rest]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic-term [1 & ?rest]))
 1. Entering `variadic-term`/1: (variadic-term [1])
 1. Matched head (variadic-term [1]): (variadic-term [1])
 1. Succeeded `variadic-term`/1: (variadic-term [1])
Recorded answer: []
 1. Backtracking into `variadic-term`/1 (1 matching assertions remain): (variadic-term [1 & ?rest:0])
 1. Succeeded `variadic-term`/1: (variadic-term [1 2])
Recorded answer: [2]
 1. Backtracking into `variadic-term`/1 (0 matching assertions remain): (variadic-term [1 & ?rest:0])
 1. Failed `variadic-term`/1: (variadic-term [1 & ?rest:0])
0. Exhausted query: ((variadic-term [1 & ?rest]))
[[] [2]]

(do
 (initialize-prolog)
 (assert<- '((variadic-term [1])))
 (assert<- '((variadic-term [1 2]))))

(query
 '?rest
 '((variadic-term (& ?rest)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic-term (& ?rest)))
 1. Entering `variadic-term`/1: (variadic-term [1])
 1. Matched head (variadic-term [1]): (variadic-term [1])
 1. Succeeded `variadic-term`/1: (variadic-term [1])
Recorded answer: [1]
 1. Backtracking into `variadic-term`/1 (1 matching assertions remain): (variadic-term (& ?rest:0))
 1. Succeeded `variadic-term`/1: (variadic-term [1 2])
Recorded answer: [1 2]
 1. Backtracking into `variadic-term`/1 (0 matching assertions remain): (variadic-term (& ?rest:0))
 1. Failed `variadic-term`/1: (variadic-term (& ?rest:0))
0. Exhausted query: ((variadic-term (& ?rest)))
[[1] [1 2]]

(do
 (initialize-prolog)
 (assert<- '((variadic)))
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query '?rest '((variadic & ?rest)) :limit nil :discard-subsumed true)

0. Processing query: ((variadic & ?rest))
 1. Entering `variadic`/0: (variadic)
 1. Matched head (variadic): (variadic)
 1. Succeeded `variadic`/0: (variadic)
Recorded answer: ()
 1. Backtracking into `variadic`/2 (2 matching assertions remain): (variadic & ?rest:0)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (1)
 1. Backtracking into `variadic`/2 (1 matching assertions remain): (variadic & ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (1 2)
 1. Backtracking into `variadic`/2 (0 matching assertions remain): (variadic & ?rest:0)
 1. Failed `variadic`/2: (variadic & ?rest:0)
0. Exhausted query: ((variadic & ?rest))
[() (1) (1 2)]

(do
 (initialize-prolog)
 (assert<- '((variadic)))
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query '?rest '((& ?rest)) :limit nil :discard-subsumed true)

0. Processing query: ((& ?rest))
 1. Entering `variadic`/0: (variadic)
 1. Matched head (variadic): (variadic)
 1. Succeeded `variadic`/0: (variadic)
Recorded answer: (variadic)
 1. Backtracking into `&`/1 (2 matching assertions remain): (& ?rest:0)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (variadic 1)
 1. Backtracking into `&`/1 (1 matching assertions remain): (& ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (variadic 1 2)
 1. Backtracking into `&`/1 (0 matching assertions remain): (& ?rest:0)
 1. Failed `&`/1: (& ?rest:0)
0. Exhausted query: ((& ?rest))
[(variadic) (variadic 1) (variadic 1 2)]

(do (initialize-prolog) (assert<- '((variadic & ?rest))))

(query 'true '((variadic 1)) :limit nil :discard-subsumed true)

0. Processing query: ((variadic 1))
 1. Entering `variadic`/1: (variadic 1)
 1. Matched head (variadic & ?rest:1): (variadic 1)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '(([complex] 1))))

(query '?x '(([complex] ?x)) :limit nil :discard-subsumed true)

0. Processing query: (([complex] ?x))
 1. Entering `[complex]`/1: ([complex] 1)
 1. Matched head ([complex] 1): ([complex] 1)
 1. Succeeded `[complex]`/1: ([complex] 1)
Recorded answer: 1
 1. Backtracking into `[complex]`/1 (0 matching assertions remain): ([complex] ?x:0)
 1. Failed `[complex]`/1: ([complex] ?x:0)
0. Exhausted query: (([complex] ?x))
[1]

(do (initialize-prolog) (assert<- '(([complex 1] 1))))

(query '?x '(([complex ?x] ?x)) :limit nil :discard-subsumed true)

0. Processing query: (([complex ?x] ?x))
 1. Entering `[complex 1]`/1: ([complex 1] 1)
 1. Matched head ([complex 1] 1): ([complex 1] 1)
 1. Succeeded `[complex 1]`/1: ([complex 1] 1)
Recorded answer: 1
 1. Backtracking into `[complex ?x:0]`/1 (0 matching assertions remain): ([complex ?x:0] ?x:0)
 1. Failed `[complex ?x:0]`/1: ([complex ?x:0] ?x:0)
0. Exhausted query: (([complex ?x] ?x))
[1]

(do (initialize-prolog) (assert<- '(([complex ?x] ?x))))

(query 'true '(([complex 1] 1)) :limit nil :discard-subsumed true)

0. Processing query: (([complex 1] 1))
 1. Entering `[complex 1]`/1: ([complex 1] 1)
 1. Matched head ([complex ?x:1] ?x:1): ([complex 1] 1)
 1. Succeeded `[complex 1]`/1: ([complex 1] 1)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '(([complex & ?rest] ?rest))))

(query 'true '(([complex 1] (1))) :limit nil :discard-subsumed true)

0. Processing query: (([complex 1] (1)))
 1. Entering `[complex 1]`/1: ([complex 1] (1))
 1. Matched head ([complex & ?rest:1] ?rest:1): ([complex 1] [1])
 1. Succeeded `[complex 1]`/1: ([complex 1] [1])
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query 'true '((member 1 (1 2 3))) :limit nil :discard-subsumed true)

0. Processing query: ((member 1 (1 2 3)))
 1. Entering `member`/2: (member 1 (1 2 3))
 1. Matched head (member ?item:1 (?item:1 & ?rest:1)): (member 1 (1 2 3))
 1. Succeeded `member`/2: (member 1 (1 2 3))
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query '?x '((member ?x (1 2 3))) :limit nil :discard-subsumed true)

0. Processing query: ((member ?x (1 2 3)))
 1. Entering `member`/2: (member 1 (1 2 3))
 1. Matched head (member ?item:1 (?item:1 & ?rest:1)): (member 1 (1 2 3))
 1. Succeeded `member`/2: (member 1 (1 2 3))
Recorded answer: 1
 1. Backtracking into `member`/2 (1 matching assertions remain): (member ?x:0 (1 2 3))
  1. (different): Entering (different (2 3) ())
  1. (different): Succeeded (different (2 3) ())
  2. Entering `member`/2: (member 2 (2 3))
  2. Matched head (member ?item:2 (?item:2 & ?rest:2)): (member 2 (2 3))
  2. Succeeded `member`/2: (member 2 (2 3))
Recorded answer: 2
  2. Backtracking into `member`/2 (2 matching assertions remain): (member ?x:0 (2 3))
  2. Succeeded `member`/2: (member 3 (2 3))
Recorded answer: 3
  2. Backtracking into `member`/2 (1 matching assertions remain): (member ?x:0 (2 3))
   2. (different): Entering (different (3) ())
   2. (different): Succeeded (different (3) ())
   3. Entering `member`/2: (member 3 (3))
   3. Matched head (member ?item:3 (?item:3 & ?rest:3)): (member 3 (3))
   3. Succeeded `member`/2: (member 3 (3))
Duplicate answer (not recorded): 3
   3. Backtracking into `member`/2 (1 matching assertions remain): (member ?x:0 (3))
    3. (different): Entering (different () ())
    3. (different): Failed (different () ())
   3. Backtracking into `member`/2 (0 matching assertions remain): (member ?x:0 (3))
   3. Failed `member`/2: (member ?x:0 (3))
  2. Backtracking into `member`/2 (0 matching assertions remain): (member ?x:0 (2 3))
  2. Failed `member`/2: (member ?x:0 (2 3))
 1. Backtracking into `member`/2 (0 matching assertions remain): (member ?x:0 (1 2 3))
 1. Failed `member`/2: (member ?x:0 (1 2 3))
0. Exhausted query: ((member ?x (1 2 3)))
[1 2 3]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query 'true '((member 2 ?)) :limit nil :discard-subsumed true)

0. Processing query: ((member 2 ?))
 1. Entering `member`/2: (member 2 (2 & ?rest:1))
 1. Matched head (member ?item:1 (?item:1 & ?rest:1)): (member 2 (2 & ?rest:1))
 1. Succeeded `member`/2: (member 2 (2 & ?rest:1))
Recorded answer: true
 1. Backtracking into `member`/2 (2 matching assertions remain): (member 2 ?anon-0:0)
 1. Succeeded `member`/2: (member 2 (?x:1 2))
Duplicate answer (not recorded): true
 1. Backtracking into `member`/2 (1 matching assertions remain): (member 2 ?anon-0:0)
  1. (different): Entering (different ?rest:1 ())
  1. (different): Failed (different ?rest:1 ())
 1. Backtracking into `member`/2 (0 matching assertions remain): (member 2 ?anon-0:0)
 1. Failed `member`/2: (member 2 ?anon-0:0)
0. Exhausted query: ((member 2 ?))
[true]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query
 '?numbers
 '((same ?numbers (?first)) (member 1 ?numbers))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same ?numbers (?first)) (member 1 ?numbers))
 0. (same): Entering (same ?numbers:0 (?first:0))
 0. (same): Succeeded (same (?first:0) (?first:0))
 1. Entering `member`/2: (member 1 (1))
 1. Matched head (member ?item:1 (?item:1 & ?rest:1)): (member 1 (1))
 1. Succeeded `member`/2: (member 1 (1))
Recorded answer: (1)
 1. Backtracking into `member`/2 (1 matching assertions remain): (member 1 (?first:0))
  1. (different): Entering (different () ())
  1. (different): Failed (different () ())
 1. Backtracking into `member`/2 (0 matching assertions remain): (member 1 (?first:0))
 1. Failed `member`/2: (member 1 (?first:0))
0. Exhausted query: ((same ?numbers (?first)) (member 1 ?numbers))
[(1)]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query
 '?numbers
 '((same ?numbers (?)) (member 1 ?numbers))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same ?numbers (?)) (member 1 ?numbers))
 0. (same): Entering (same ?numbers:0 (?anon-0:0))
 0. (same): Succeeded (same (?anon-0:0) (?anon-0:0))
 1. Entering `member`/2: (member 1 (1))
 1. Matched head (member ?item:1 (?item:1 & ?rest:1)): (member 1 (1))
 1. Succeeded `member`/2: (member 1 (1))
Recorded answer: (1)
 1. Backtracking into `member`/2 (1 matching assertions remain): (member 1 (?anon-0:0))
  1. (different): Entering (different () ())
  1. (different): Failed (different () ())
 1. Backtracking into `member`/2 (0 matching assertions remain): (member 1 (?anon-0:0))
 1. Failed `member`/2: (member 1 (?anon-0:0))
0. Exhausted query: ((same ?numbers (?)) (member 1 ?numbers))
[(1)]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query
 '?numbers
 '((same ?numbers (1 2 ?)) (member 3 ?numbers))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same ?numbers (1 2 ?)) (member 3 ?numbers))
 0. (same): Entering (same ?numbers:0 (1 2 ?anon-0:0))
 0. (same): Succeeded (same (1 2 ?anon-0:0) (1 2 ?anon-0:0))
 1. Entering `member`/2: (member 3 (1 2 ?anon-0:0))
 1. Matched head (member ?item:1 (?x:1 & ?rest:1)): (member 3 (1 2 ?anon-0:0))
  1. (different): Entering (different (2 ?anon-0:0) ())
  1. (different): Succeeded (different (2 ?anon-0:0) ())
  2. Entering `member`/2: (member 3 (2 3))
  2. Matched head (member ?item:2 (?x:2 ?item:2)): (member 3 (2 3))
  2. Succeeded `member`/2: (member 3 (2 3))
Recorded answer: (1 2 3)
  2. Backtracking into `member`/2 (1 matching assertions remain): (member 3 (2 ?anon-0:0))
   2. (different): Entering (different (?anon-0:0) ())
   2. (different): Succeeded (different (?anon-0:0) ())
   3. Entering `member`/2: (member 3 (3))
   3. Matched head (member ?item:3 (?item:3 & ?rest:3)): (member 3 (3))
   3. Succeeded `member`/2: (member 3 (3))
Duplicate answer (not recorded): (1 2 3)
   3. Backtracking into `member`/2 (1 matching assertions remain): (member 3 (?anon-0:0))
    3. (different): Entering (different () ())
    3. (different): Failed (different () ())
   3. Backtracking into `member`/2 (0 matching assertions remain): (member 3 (?anon-0:0))
   3. Failed `member`/2: (member 3 (?anon-0:0))
  2. Backtracking into `member`/2 (0 matching assertions remain): (member 3 (2 ?anon-0:0))
  2. Failed `member`/2: (member 3 (2 ?anon-0:0))
 1. Backtracking into `member`/2 (0 matching assertions remain): (member 3 (1 2 ?anon-0:0))
 1. Failed `member`/2: (member 3 (1 2 ?anon-0:0))
0. Exhausted query: ((same ?numbers (1 2 ?)) (member 3 ?numbers))
[(1 2 3)]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query 'true '((iright 1 2 (1 2 3))) :limit nil :discard-subsumed true)

0. Processing query: ((iright 1 2 (1 2 3)))
 1. Entering `iright`/3: (iright 1 2 (1 2 3))
 1. Matched head (iright ?left:1 ?right:1 (?left:1 ?right:1 & ?rest:1)): (iright 1 2 (1 2 3))
 1. Succeeded `iright`/3: (iright 1 2 (1 2 3))
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query
 '[?l ?r]
 '((iright ?l ?r (1 2 3)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((iright ?l ?r (1 2 3)))
 1. Entering `iright`/3: (iright 1 2 (1 2 3))
 1. Matched head (iright ?left:1 ?right:1 (?left:1 ?right:1 & ?rest:1)): (iright 1 2 (1 2 3))
 1. Succeeded `iright`/3: (iright 1 2 (1 2 3))
Recorded answer: [1 2]
 1. Backtracking into `iright`/3 (1 matching assertions remain): (iright ?l:0 ?r:0 (1 2 3))
  1. (different): Entering (different (2 3) (?anon-1:1))
  1. (different): Succeeded (different (2 3) (?anon-1:1))
  2. Entering `iright`/3: (iright 2 3 (2 3))
  2. Matched head (iright ?left:2 ?right:2 (?left:2 ?right:2 & ?rest:2)): (iright 2 3 (2 3))
  2. Succeeded `iright`/3: (iright 2 3 (2 3))
Recorded answer: [2 3]
  2. Backtracking into `iright`/3 (1 matching assertions remain): (iright ?l:0 ?r:0 (2 3))
   2. (different): Entering (different (3) (?anon-1:2))
   2. (different): Failed (different (3) (?anon-1:2))
  2. Backtracking into `iright`/3 (0 matching assertions remain): (iright ?l:0 ?r:0 (2 3))
  2. Failed `iright`/3: (iright ?l:0 ?r:0 (2 3))
 1. Backtracking into `iright`/3 (0 matching assertions remain): (iright ?l:0 ?r:0 (1 2 3))
 1. Failed `iright`/3: (iright ?l:0 ?r:0 (1 2 3))
0. Exhausted query: ((iright ?l ?r (1 2 3)))
[[1 2] [2 3]]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query
 '[?a ?b]
 '((nextto ?a ?b (1 2 3)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((nextto ?a ?b (1 2 3)))
 1. Entering `nextto`/3: (nextto ?a:0 ?b:0 (1 2 3))
 1. Matched head (nextto ?x:1 ?y:1 ?list:1): (nextto ?a:0 ?b:0 (1 2 3))
  2. Entering `iright`/3: (iright 1 2 (1 2 3))
  2. Matched head (iright ?left:1 ?right:1 (?left:1 ?right:1 & ?rest:1)): (iright 1 2 (1 2 3))
  2. Succeeded `iright`/3: (iright 1 2 (1 2 3))
Recorded answer: [1 2]
  2. Backtracking into `iright`/3 (1 matching assertions remain): (iright ?a:0 ?b:0 (1 2 3))
   2. (different): Entering (different (2 3) (?anon-1:1))
   2. (different): Succeeded (different (2 3) (?anon-1:1))
   3. Entering `iright`/3: (iright 2 3 (2 3))
   3. Matched head (iright ?left:3 ?right:3 (?left:3 ?right:3 & ?rest:3)): (iright 2 3 (2 3))
   3. Succeeded `iright`/3: (iright 2 3 (2 3))
Recorded answer: [2 3]
   3. Backtracking into `iright`/3 (1 matching assertions remain): (iright ?a:0 ?b:0 (2 3))
    3. (different): Entering (different (3) (?anon-1:3))
    3. (different): Failed (different (3) (?anon-1:3))
   3. Backtracking into `iright`/3 (0 matching assertions remain): (iright ?a:0 ?b:0 (2 3))
   3. Failed `iright`/3: (iright ?a:0 ?b:0 (2 3))
  2. Backtracking into `iright`/3 (0 matching assertions remain): (iright ?a:0 ?b:0 (1 2 3))
  2. Failed `iright`/3: (iright ?a:0 ?b:0 (1 2 3))
 1. Backtracking into `nextto`/3 (1 matching assertions remain): (nextto ?a:0 ?b:0 (1 2 3))
  2. Entering `iright`/3: (iright 1 2 (1 2 3))
  2. Matched head (iright ?left:1 ?right:1 (?left:1 ?right:1 & ?rest:1)): (iright 1 2 (1 2 3))
  2. Succeeded `iright`/3: (iright 1 2 (1 2 3))
Recorded answer: [2 1]
  2. Backtracking into `iright`/3 (1 matching assertions remain): (iright ?b:0 ?a:0 (1 2 3))
   2. (different): Entering (different (2 3) (?anon-1:1))
   2. (different): Succeeded (different (2 3) (?anon-1:1))
   3. Entering `iright`/3: (iright 2 3 (2 3))
   3. Matched head (iright ?left:3 ?right:3 (?left:3 ?right:3 & ?rest:3)): (iright 2 3 (2 3))
   3. Succeeded `iright`/3: (iright 2 3 (2 3))
Recorded answer: [3 2]
   3. Backtracking into `iright`/3 (1 matching assertions remain): (iright ?b:0 ?a:0 (2 3))
    3. (different): Entering (different (3) (?anon-1:3))
    3. (different): Failed (different (3) (?anon-1:3))
   3. Backtracking into `iright`/3 (0 matching assertions remain): (iright ?b:0 ?a:0 (2 3))
   3. Failed `iright`/3: (iright ?b:0 ?a:0 (2 3))
  2. Backtracking into `iright`/3 (0 matching assertions remain): (iright ?b:0 ?a:0 (1 2 3))
  2. Failed `iright`/3: (iright ?b:0 ?a:0 (1 2 3))
 1. Backtracking into `nextto`/3 (0 matching assertions remain): (nextto ?a:0 ?b:0 (1 2 3))
 1. Failed `nextto`/3: (nextto ?a:0 ?b:0 (1 2 3))
0. Exhausted query: ((nextto ?a ?b (1 2 3)))
[[1 2] [2 3] [2 1] [3 2]]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query
 '((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
   (house englishman ?anon-11 ?anon-12 ?anon-13 red)
   (house spaniard dog ?anon-7 milk ?anon-8)
   (house ?anon-17 ?anon-18 ?anon-19 coffee green)
   (house ukrainian ?anon-20 ?anon-21 tea ?anon-22))
 '((iright
    (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
    (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
    ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
     (house englishman ?anon-11 ?anon-12 ?anon-13 red)
     (house spaniard dog ?anon-7 milk ?anon-8)
     (house ?anon-17 ?anon-18 ?anon-19 coffee green)
     (house ukrainian ?anon-20 ?anon-21 tea ?anon-22))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((iright (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory) (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green) ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3) (house englishman ?anon-11 ?anon-12 ?anon-13 red) (house spaniard dog ?anon-7 milk ?anon-8) (house ?anon-17 ?anon-18 ?anon-19 coffee green) (house ukrainian ?anon-20 ?anon-21 tea ?anon-22))))
 1. Entering `iright`/3:
    (iright
     (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
     (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
     ((house norwegian ?anon-0:0 ?anon-1:0 ?anon-2:0 ?anon-3:0)
      (house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
      (house spaniard dog ?anon-7:0 milk ?anon-8:0)
      (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
      (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

  1. (different): Entering...
                  (different
                   ((house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
                    (house spaniard dog ?anon-7:0 milk ?anon-8:0)
                    (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
                    (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                   (?anon-1:1))

  1. (different): Succeeded...
                  (different
                   ((house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
                    (house spaniard dog ?anon-7:0 milk ?anon-8:0)
                    (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
                    (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                   (?anon-1:1))

  2. Entering `iright`/3:
     (iright
      (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
      (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
      ((house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
       (house spaniard dog ?anon-7:0 milk ?anon-8:0)
       (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
       (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

   2. (different): Entering...
                   (different
                    ((house spaniard dog ?anon-7:0 milk ?anon-8:0)
                     (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
                     (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                    (?anon-1:2))

   2. (different): Succeeded...
                   (different
                    ((house spaniard dog ?anon-7:0 milk ?anon-8:0)
                     (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
                     (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                    (?anon-1:2))

   3. Entering `iright`/3:
      (iright
       (house spaniard dog ?anon-7:0 milk ivory)
       (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
       ((house spaniard dog ?anon-7:0 milk ivory)
        (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
        (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

   3. Succeeded `iright`/3:
      (iright
       (house spaniard dog ?anon-7:0 milk ivory)
       (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
       ((house spaniard dog ?anon-7:0 milk ivory)
        (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
        (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

Recorded answer: ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3) (house englishman ?anon-11 ?anon-12 ?anon-13 red) (house spaniard dog ?anon-7 milk ivory) (house ?anon-17 ?anon-18 ?anon-19 coffee green) (house ukrainian ?anon-20 ?anon-21 tea ?anon-22))
   3. Backtracking into `iright`/3 (1 matching assertions remain):
      (iright
       (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
       (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
       ((house spaniard dog ?anon-7:0 milk ?anon-8:0)
        (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
        (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

    3. (different): Entering...
                    (different
                     ((house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
                      (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                     (?anon-1:3))

    3. (different): Succeeded...
                    (different
                     ((house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
                      (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                     (?anon-1:3))

    4. Entering `iright`/3:
       (iright
        (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
        (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
        ((house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
         (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

     4. (different): Entering...
                     (different
                      ((house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                      (?anon-1:4))

     4. (different): Failed...
                     (different
                      ((house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0))
                      (?anon-1:4))

    4. Backtracking into `iright`/3 (0 matching assertions remain):
       (iright
        (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
        (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
        ((house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
         (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

    4. Failed `iright`/3:
       (iright
        (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
        (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
        ((house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
         (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

   3. Backtracking into `iright`/3 (0 matching assertions remain):
      (iright
       (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
       (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
       ((house spaniard dog ?anon-7:0 milk ?anon-8:0)
        (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
        (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

   3. Failed `iright`/3:
      (iright
       (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
       (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
       ((house spaniard dog ?anon-7:0 milk ?anon-8:0)
        (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
        (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

  2. Backtracking into `iright`/3 (0 matching assertions remain):
     (iright
      (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
      (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
      ((house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
       (house spaniard dog ?anon-7:0 milk ?anon-8:0)
       (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
       (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

  2. Failed `iright`/3:
     (iright
      (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
      (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
      ((house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
       (house spaniard dog ?anon-7:0 milk ?anon-8:0)
       (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
       (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

 1. Backtracking into `iright`/3 (0 matching assertions remain):
    (iright
     (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
     (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
     ((house norwegian ?anon-0:0 ?anon-1:0 ?anon-2:0 ?anon-3:0)
      (house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
      (house spaniard dog ?anon-7:0 milk ?anon-8:0)
      (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
      (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

 1. Failed `iright`/3:
    (iright
     (house ?anon-23:0 ?anon-24:0 ?anon-25:0 ?anon-26:0 ivory)
     (house ?anon-27:0 ?anon-28:0 ?anon-29:0 ?anon-30:0 green)
     ((house norwegian ?anon-0:0 ?anon-1:0 ?anon-2:0 ?anon-3:0)
      (house englishman ?anon-11:0 ?anon-12:0 ?anon-13:0 red)
      (house spaniard dog ?anon-7:0 milk ?anon-8:0)
      (house ?anon-17:0 ?anon-18:0 ?anon-19:0 coffee green)
      (house ukrainian ?anon-20:0 ?anon-21:0 tea ?anon-22:0)))

0. Exhausted query: ((iright (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory) (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green) ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3) (house englishman ?anon-11 ?anon-12 ?anon-13 red) (house spaniard dog ?anon-7 milk ?anon-8) (house ?anon-17 ?anon-18 ?anon-19 coffee green) (house ukrainian ?anon-20 ?anon-21 tea ?anon-22))))
[((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
  (house englishman ?anon-11 ?anon-12 ?anon-13 red)
  (house spaniard dog ?anon-7 milk ivory)
  (house ?anon-17 ?anon-18 ?anon-19 coffee green)
  (house ukrainian ?anon-20 ?anon-21 tea ?anon-22))]

(do
 (initialize-prolog)
 (assert<- '((member ?item (?item & ?rest))))
 (assert<- '((member ?item (?x ?item))))
 (assert<-
  '((member ?item (?x & ?rest))
    (different ?rest ())
    (member ?item ?rest)))
 (assert<- '((nextto ?x ?y ?list) (iright ?x ?y ?list)))
 (assert<- '((nextto ?x ?y ?list) (iright ?y ?x ?list)))
 (assert<- '((iright ?left ?right (?left ?right & ?rest))))
 (assert<-
  '((iright ?left ?right (?anon-0 & ?rest))
    (different ?rest (?anon-1))
    (iright ?left ?right ?rest)))
 (assert<-
  '((zebra ?houses ?w ?z)
    (same
     ?houses
     ((house norwegian ?anon-0 ?anon-1 ?anon-2 ?anon-3)
      ?anon-4
      (house ?anon-5 ?anon-6 ?anon-7 milk ?anon-8)
      ?anon-9
      ?anon-10))
    (member (house englishman ?anon-11 ?anon-12 ?anon-13 red) ?houses)
    (member (house spaniard dog ?anon-14 ?anon-15 ?anon-16) ?houses)
    (member (house ?anon-17 ?anon-18 ?anon-19 coffee green) ?houses)
    (member (house ukrainian ?anon-20 ?anon-21 tea ?anon-22) ?houses)
    (iright
     (house ?anon-23 ?anon-24 ?anon-25 ?anon-26 ivory)
     (house ?anon-27 ?anon-28 ?anon-29 ?anon-30 green)
     ?houses)
    (member (house ?anon-31 snails winston ?anon-32 ?anon-33) ?houses)
    (member (house ?anon-34 ?anon-35 kools ?anon-36 yellow) ?houses)
    (nextto
     (house ?anon-37 ?anon-38 chesterfield ?anon-39 ?anon-40)
     (house ?anon-41 fox ?anon-42 ?anon-43 ?anon-44)
     ?houses)
    (nextto
     (house ?anon-45 ?anon-46 kools ?anon-47 ?anon-48)
     (house ?anon-49 horse ?anon-50 ?anon-51 ?anon-52)
     ?houses)
    (member (house ?anon-53 ?anon-54 luckystrike oj ?anon-55) ?houses)
    (member
     (house japanese ?anon-56 parliaments ?anon-57 ?anon-58)
     ?houses)
    (nextto
     (house norwegian ?anon-59 ?anon-60 ?anon-61 ?anon-62)
     (house ?anon-63 ?anon-64 ?anon-65 ?anon-66 blue)
     ?houses)
    (member (house ?w ?anon-67 ?anon-68 water ?anon-69) ?houses)
    (member (house ?z zebra ?anon-70 ?anon-71 ?anon-72) ?houses))))

(query
 '(? red ivory green)
 '((iright ivory green (? red ? green)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((iright ivory green (? red ? green)))
 1. Entering `iright`/3: (iright ivory green (?anon-0:0 red ?anon-1:0 green))
 1. Matched head (iright ?left:1 ?right:1 (?anon-0:1 & ?rest:1)): (iright ivory green (?anon-0:0 red ?anon-1:0 green))
  1. (different): Entering (different (red ?anon-1:0 green) (?anon-1:1))
  1. (different): Succeeded (different (red ?anon-1:0 green) (?anon-1:1))
  2. Entering `iright`/3: (iright ivory green (red ?anon-1:0 green))
  2. Matched head (iright ?left:2 ?right:2 (?anon-0:2 & ?rest:2)): (iright ivory green (red ?anon-1:0 green))
   2. (different): Entering (different (?anon-1:0 green) (?anon-1:2))
   2. (different): Succeeded (different (?anon-1:0 green) (?anon-1:2))
   3. Entering `iright`/3: (iright ivory green (ivory green))
   3. Matched head (iright ?left:3 ?right:3 (?left:3 ?right:3 & ?rest:3)): (iright ivory green (ivory green))
   3. Succeeded `iright`/3: (iright ivory green (ivory green))
Recorded answer: (? red ivory green)
   3. Backtracking into `iright`/3 (1 matching assertions remain): (iright ivory green (?anon-1:0 green))
    3. (different): Entering (different (green) (?anon-1:3))
    3. (different): Failed (different (green) (?anon-1:3))
   3. Backtracking into `iright`/3 (0 matching assertions remain): (iright ivory green (?anon-1:0 green))
   3. Failed `iright`/3: (iright ivory green (?anon-1:0 green))
  2. Backtracking into `iright`/3 (0 matching assertions remain): (iright ivory green (red ?anon-1:0 green))
  2. Failed `iright`/3: (iright ivory green (red ?anon-1:0 green))
 1. Backtracking into `iright`/3 (0 matching assertions remain): (iright ivory green (?anon-0:0 red ?anon-1:0 green))
 1. Failed `iright`/3: (iright ivory green (?anon-0:0 red ?anon-1:0 green))
0. Exhausted query: ((iright ivory green (? red ? green)))
[(? red ivory green)]
