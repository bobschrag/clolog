
(do (initialize-prolog))

(query 'true '((pseudo-fail)) :limit nil :discard-subsumed true)

0. Processing query: ((pseudo-fail))
 1. Entering `pseudo-fail`/0: (pseudo-fail)
 1. Failed `pseudo-fail`/0: (pseudo-fail)
0. Exhausted query: ((pseudo-fail))
[]

(do (initialize-prolog))

(query 'true '() :limit nil :discard-subsumed true)


(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 'true
 '((has-subtype vertebrate mammal))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype vertebrate mammal))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '?x
 '((has-subtype vertebrate ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype vertebrate ?x))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: mammal
 1. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?x:0)
 1. Failed `has-subtype`/2: (has-subtype vertebrate ?x:0)
0. Exhausted query: ((has-subtype vertebrate ?x))
[mammal]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '(has-subtype ?type ?subtype)
 '((has-subtype ?type ?subtype))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype ?type ?subtype))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: (has-subtype vertebrate mammal)
 1. Backtracking into `has-subtype`/2: (has-subtype ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: (has-subtype mammal primate)
 1. Backtracking into `has-subtype`/2: (has-subtype ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: (has-subtype primate human)
 1. Backtracking into `has-subtype`/2: (has-subtype ?type:0 ?subtype:0)
 1. Failed `has-subtype`/2: (has-subtype ?type:0 ?subtype:0)
0. Exhausted query: ((has-subtype ?type ?subtype))
[(has-subtype vertebrate mammal)
 (has-subtype mammal primate)
 (has-subtype primate human)]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '(?pred ?type ?subtype)
 '((?pred ?type ?subtype))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((?pred ?type ?subtype))
 1. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
 1. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
 1. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: (has-subtype vertebrate mammal)
 1. Backtracking into `?pred:0`/2: (?pred:0 ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: (has-subtype mammal primate)
 1. Backtracking into `?pred:0`/2: (?pred:0 ?type:0 ?subtype:0)
 1. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: (has-subtype primate human)
 1. Backtracking into `?pred:0`/2: (?pred:0 ?type:0 ?subtype:0)
 1. Failed `?pred:0`/2: (?pred:0 ?type:0 ?subtype:0)
0. Exhausted query: ((?pred ?type ?subtype))
[(has-subtype vertebrate mammal)
 (has-subtype mammal primate)
 (has-subtype primate human)]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human))))

(query
 '(?subtype)
 '((has-subtype mammal ?subtype) (has-subtype ?subtype human))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype mammal ?subtype) (has-subtype ?subtype human))
 1. Entering `has-subtype`/2: (has-subtype mammal primate)
 1. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
 1. Succeeded `has-subtype`/2: (has-subtype mammal primate)
 1. Entering `has-subtype`/2: (has-subtype primate human)
 1. Matched head (has-subtype primate human): (has-subtype primate human)
 1. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: (primate)
 1. Backtracking into `has-subtype`/2: (has-subtype primate human)
 1. Failed `has-subtype`/2: (has-subtype primate human)
 1. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:0)
 1. Failed `has-subtype`/2: (has-subtype mammal ?subtype:0)
0. Exhausted query: ((has-subtype mammal ?subtype) (has-subtype ?subtype human))
[(primate)]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `has-subtype*`/2: (has-subtype* mammal primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal primate)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 false)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `has-subtype*`/2: (has-subtype* mammal primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal primate)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
    4. Backtracking into `has-subtype`/2: (has-subtype mammal primate)
    4. Failed `has-subtype`/2: (has-subtype mammal primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `has-subtype*`/2: (has-subtype* primate primate)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate primate)
      6. Entering `has-subtype`/2: (has-subtype primate primate)
      6. Failed `has-subtype`/2: (has-subtype primate primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
      6. Entering `has-subtype`/2: (has-subtype primate human)
      6. Matched head (has-subtype primate human): (has-subtype primate human)
      6. Succeeded `has-subtype`/2: (has-subtype primate human)
       7. Entering `has-subtype*`/2: (has-subtype* human primate)
       7. Matched head (has-subtype* ?type:7 ?subtype:7): (has-subtype* human primate)
        8. Entering `has-subtype`/2: (has-subtype human primate)
        8. Failed `has-subtype`/2: (has-subtype human primate)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human primate)
        8. Entering `has-subtype`/2: (has-subtype human ?subtype:7)
        8. Failed `has-subtype`/2: (has-subtype human ?subtype:7)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human primate)
       7. Failed `has-subtype*`/2: (has-subtype* human primate)
      6. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:5)
      6. Failed `has-subtype`/2: (has-subtype primate ?subtype:5)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
     5. Failed `has-subtype*`/2: (has-subtype* primate primate)
    4. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
   3. Failed `has-subtype*`/2: (has-subtype* mammal primate)
  2. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate primate)
0. Exhausted query: ((has-subtype* vertebrate primate))
[true]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 '?x
 '((has-subtype* vertebrate ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate ?x))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate ?x:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: mammal
  2. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?x:0)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?x:0)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `has-subtype*`/2: (has-subtype* mammal ?x:0)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal ?x:0)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: primate
    4. Backtracking into `has-subtype`/2: (has-subtype mammal ?x:0)
    4. Failed `has-subtype`/2: (has-subtype mammal ?x:0)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal ?x:0)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `has-subtype*`/2: (has-subtype* primate ?x:0)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate ?x:0)
      6. Entering `has-subtype`/2: (has-subtype primate human)
      6. Matched head (has-subtype primate human): (has-subtype primate human)
      6. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: human
      6. Backtracking into `has-subtype`/2: (has-subtype primate ?x:0)
      6. Failed `has-subtype`/2: (has-subtype primate ?x:0)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate ?x:0)
      6. Entering `has-subtype`/2: (has-subtype primate human)
      6. Matched head (has-subtype primate human): (has-subtype primate human)
      6. Succeeded `has-subtype`/2: (has-subtype primate human)
       7. Entering `has-subtype*`/2: (has-subtype* human ?x:0)
       7. Matched head (has-subtype* ?type:7 ?subtype:7): (has-subtype* human ?x:0)
        8. Entering `has-subtype`/2: (has-subtype human ?x:0)
        8. Failed `has-subtype`/2: (has-subtype human ?x:0)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human ?x:0)
        8. Entering `has-subtype`/2: (has-subtype human ?subtype:7)
        8. Failed `has-subtype`/2: (has-subtype human ?subtype:7)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human ?x:0)
       7. Failed `has-subtype*`/2: (has-subtype* human ?x:0)
      6. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:5)
      6. Failed `has-subtype`/2: (has-subtype primate ?subtype:5)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate ?x:0)
     5. Failed `has-subtype*`/2: (has-subtype* primate ?x:0)
    4. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal ?x:0)
   3. Failed `has-subtype*`/2: (has-subtype* mammal ?x:0)
  2. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
0. Exhausted query: ((has-subtype* vertebrate ?x))
[mammal primate human]

(do
 (initialize-prolog)
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (has-subtype ?type ?subtype)
    (has-subtype* ?subtype ?subsubtype))))

(query
 '[?x ?y]
 '((has-subtype* ?x ?y))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* ?x ?y))
 1. Entering `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* ?x:0 ?y:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: [vertebrate mammal]
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [mammal primate]
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [primate human]
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?y:0)
  2. Failed `has-subtype`/2: (has-subtype ?x:0 ?y:0)
 1. Backtracking into `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `has-subtype*`/2: (has-subtype* mammal ?y:0)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal ?y:0)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [vertebrate primate]
    4. Backtracking into `has-subtype`/2: (has-subtype mammal ?y:0)
    4. Failed `has-subtype`/2: (has-subtype mammal ?y:0)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal ?y:0)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `has-subtype*`/2: (has-subtype* primate ?y:0)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate ?y:0)
      6. Entering `has-subtype`/2: (has-subtype primate human)
      6. Matched head (has-subtype primate human): (has-subtype primate human)
      6. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [vertebrate human]
      6. Backtracking into `has-subtype`/2: (has-subtype primate ?y:0)
      6. Failed `has-subtype`/2: (has-subtype primate ?y:0)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate ?y:0)
      6. Entering `has-subtype`/2: (has-subtype primate human)
      6. Matched head (has-subtype primate human): (has-subtype primate human)
      6. Succeeded `has-subtype`/2: (has-subtype primate human)
       7. Entering `has-subtype*`/2: (has-subtype* human ?y:0)
       7. Matched head (has-subtype* ?type:7 ?subtype:7): (has-subtype* human ?y:0)
        8. Entering `has-subtype`/2: (has-subtype human ?y:0)
        8. Failed `has-subtype`/2: (has-subtype human ?y:0)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human ?y:0)
        8. Entering `has-subtype`/2: (has-subtype human ?subtype:7)
        8. Failed `has-subtype`/2: (has-subtype human ?subtype:7)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human ?y:0)
       7. Failed `has-subtype*`/2: (has-subtype* human ?y:0)
      6. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:5)
      6. Failed `has-subtype`/2: (has-subtype primate ?subtype:5)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate ?y:0)
     5. Failed `has-subtype*`/2: (has-subtype* primate ?y:0)
    4. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal ?y:0)
   3. Failed `has-subtype*`/2: (has-subtype* mammal ?y:0)
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?subtype:1)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `has-subtype*`/2: (has-subtype* primate ?y:0)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate ?y:0)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [mammal human]
    4. Backtracking into `has-subtype`/2: (has-subtype primate ?y:0)
    4. Failed `has-subtype`/2: (has-subtype primate ?y:0)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate ?y:0)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
     5. Entering `has-subtype*`/2: (has-subtype* human ?y:0)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* human ?y:0)
      6. Entering `has-subtype`/2: (has-subtype human ?y:0)
      6. Failed `has-subtype`/2: (has-subtype human ?y:0)
     5. Backtracking into `has-subtype*`/2: (has-subtype* human ?y:0)
      6. Entering `has-subtype`/2: (has-subtype human ?subtype:5)
      6. Failed `has-subtype`/2: (has-subtype human ?subtype:5)
     5. Backtracking into `has-subtype*`/2: (has-subtype* human ?y:0)
     5. Failed `has-subtype*`/2: (has-subtype* human ?y:0)
    4. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate ?y:0)
   3. Failed `has-subtype*`/2: (has-subtype* primate ?y:0)
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?subtype:1)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
   3. Entering `has-subtype*`/2: (has-subtype* human ?y:0)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* human ?y:0)
    4. Entering `has-subtype`/2: (has-subtype human ?y:0)
    4. Failed `has-subtype`/2: (has-subtype human ?y:0)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human ?y:0)
    4. Entering `has-subtype`/2: (has-subtype human ?subtype:3)
    4. Failed `has-subtype`/2: (has-subtype human ?subtype:3)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human ?y:0)
   3. Failed `has-subtype*`/2: (has-subtype* human ?y:0)
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?subtype:1)
  2. Failed `has-subtype`/2: (has-subtype ?x:0 ?subtype:1)
 1. Backtracking into `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
 1. Failed `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
0. Exhausted query: ((has-subtype* ?x ?y))
[[vertebrate mammal]
 [mammal primate]
 [primate human]
 [vertebrate primate]
 [vertebrate human]
 [mammal human]]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate primate)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal primate)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 'true
 '((has-subtype* vertebrate primate))
 :limit
 nil
 :discard-subsumed
 false)

0. Processing query: ((has-subtype* vertebrate primate))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate primate)
  2. Entering `has-subtype`/2: (has-subtype vertebrate primate)
  2. Failed `has-subtype`/2: (has-subtype vertebrate primate)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate primate)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal primate)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: true
    4. Backtracking into `has-subtype`/2: (has-subtype mammal primate)
    4. Failed `has-subtype`/2: (has-subtype mammal primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
    4. Entering `is-type`/1: (is-type mammal)
    4. Matched head (is-type mammal): (is-type mammal)
    4. Succeeded `is-type`/1: (is-type mammal)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype`/2: (has-subtype mammal primate)
     5. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
     5. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype*`/2: (has-subtype* primate primate)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate primate)
      6. Entering `has-subtype`/2: (has-subtype primate primate)
      6. Failed `has-subtype`/2: (has-subtype primate primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
      6. Entering `is-type`/1: (is-type primate)
      6. Matched head (is-type primate): (is-type primate)
      6. Succeeded `is-type`/1: (is-type primate)
       7. Entering `is-type`/1: (is-type primate)
       7. Matched head (is-type primate): (is-type primate)
       7. Succeeded `is-type`/1: (is-type primate)
       (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
       (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
       7. Backtracking into `is-type`/1: (is-type primate)
       7. Failed `is-type`/1: (is-type primate)
      6. Backtracking into `is-type`/1: (is-type primate)
      6. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
     5. Failed `has-subtype*`/2: (has-subtype* primate primate)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
    4. Backtracking into `is-type`/1: (is-type mammal)
    4. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
   3. Failed `has-subtype*`/2: (has-subtype* mammal primate)
   3. Backtracking into `is-type`/1: (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
  2. Backtracking into `is-type`/1: (is-type vertebrate)
  2. Failed `is-type`/1: (is-type vertebrate)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate primate)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate primate)
0. Exhausted query: ((has-subtype* vertebrate primate))
[true]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 '?x
 '((has-subtype* vertebrate ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* vertebrate ?x))
 1. Entering `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* vertebrate ?x:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: mammal
  2. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?x:0)
  2. Failed `has-subtype`/2: (has-subtype vertebrate ?x:0)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
   3. Entering `is-type`/1: (is-type vertebrate)
   3. Matched head (is-type vertebrate): (is-type vertebrate)
   3. Succeeded `is-type`/1: (is-type vertebrate)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote vertebrate)))
   (truthy?): Failed (truthy? (not= (quote vertebrate) (quote vertebrate)))
   3. Backtracking into `is-type`/1: (is-type ?x:0)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal mammal)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal mammal)
    4. Entering `has-subtype`/2: (has-subtype mammal mammal)
    4. Failed `has-subtype`/2: (has-subtype mammal mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal mammal)
    4. Entering `is-type`/1: (is-type mammal)
    4. Matched head (is-type mammal): (is-type mammal)
    4. Succeeded `is-type`/1: (is-type mammal)
     5. Entering `is-type`/1: (is-type mammal)
     5. Matched head (is-type mammal): (is-type mammal)
     5. Succeeded `is-type`/1: (is-type mammal)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote mammal)))
     (truthy?): Failed (truthy? (not= (quote mammal) (quote mammal)))
     5. Backtracking into `is-type`/1: (is-type mammal)
     5. Failed `is-type`/1: (is-type mammal)
    4. Backtracking into `is-type`/1: (is-type mammal)
    4. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal mammal)
   3. Failed `has-subtype*`/2: (has-subtype* mammal mammal)
   3. Backtracking into `is-type`/1: (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?x:0)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal primate)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: primate
    4. Backtracking into `has-subtype`/2: (has-subtype mammal primate)
    4. Failed `has-subtype`/2: (has-subtype mammal primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
    4. Entering `is-type`/1: (is-type mammal)
    4. Matched head (is-type mammal): (is-type mammal)
    4. Succeeded `is-type`/1: (is-type mammal)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype`/2: (has-subtype mammal primate)
     5. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
     5. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype*`/2: (has-subtype* primate primate)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate primate)
      6. Entering `has-subtype`/2: (has-subtype primate primate)
      6. Failed `has-subtype`/2: (has-subtype primate primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
      6. Entering `is-type`/1: (is-type primate)
      6. Matched head (is-type primate): (is-type primate)
      6. Succeeded `is-type`/1: (is-type primate)
       7. Entering `is-type`/1: (is-type primate)
       7. Matched head (is-type primate): (is-type primate)
       7. Succeeded `is-type`/1: (is-type primate)
       (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
       (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
       7. Backtracking into `is-type`/1: (is-type primate)
       7. Failed `is-type`/1: (is-type primate)
      6. Backtracking into `is-type`/1: (is-type primate)
      6. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
     5. Failed `has-subtype*`/2: (has-subtype* primate primate)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
    4. Backtracking into `is-type`/1: (is-type mammal)
    4. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
   3. Failed `has-subtype*`/2: (has-subtype* mammal primate)
   3. Backtracking into `is-type`/1: (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?x:0)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote human)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote human)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal human)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal human)
    4. Entering `has-subtype`/2: (has-subtype mammal human)
    4. Failed `has-subtype`/2: (has-subtype mammal human)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal human)
    4. Entering `is-type`/1: (is-type mammal)
    4. Matched head (is-type mammal): (is-type mammal)
    4. Succeeded `is-type`/1: (is-type mammal)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote human)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote human)))
     5. Entering `has-subtype`/2: (has-subtype mammal primate)
     5. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
     5. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype*`/2: (has-subtype* primate human)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate human)
      6. Entering `has-subtype`/2: (has-subtype primate human)
      6. Matched head (has-subtype primate human): (has-subtype primate human)
      6. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: human
      6. Backtracking into `has-subtype`/2: (has-subtype primate human)
      6. Failed `has-subtype`/2: (has-subtype primate human)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate human)
      6. Entering `is-type`/1: (is-type primate)
      6. Matched head (is-type primate): (is-type primate)
      6. Succeeded `is-type`/1: (is-type primate)
       7. Entering `is-type`/1: (is-type human)
       7. Matched head (is-type human): (is-type human)
       7. Succeeded `is-type`/1: (is-type human)
       (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
       (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
       7. Entering `has-subtype`/2: (has-subtype primate human)
       7. Matched head (has-subtype primate human): (has-subtype primate human)
       7. Succeeded `has-subtype`/2: (has-subtype primate human)
       7. Entering `is-type`/1: (is-type human)
       7. Matched head (is-type human): (is-type human)
       7. Succeeded `is-type`/1: (is-type human)
       (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
       (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
       7. Entering `has-subtype*`/2: (has-subtype* human human)
       7. Matched head (has-subtype* ?type:7 ?subtype:7): (has-subtype* human human)
        8. Entering `has-subtype`/2: (has-subtype human human)
        8. Failed `has-subtype`/2: (has-subtype human human)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human human)
        8. Entering `is-type`/1: (is-type human)
        8. Matched head (is-type human): (is-type human)
        8. Succeeded `is-type`/1: (is-type human)
         9. Entering `is-type`/1: (is-type human)
         9. Matched head (is-type human): (is-type human)
         9. Succeeded `is-type`/1: (is-type human)
         (truthy?): Entering (truthy? (not= (quote human) (quote human)))
         (truthy?): Failed (truthy? (not= (quote human) (quote human)))
         9. Backtracking into `is-type`/1: (is-type human)
         9. Failed `is-type`/1: (is-type human)
        8. Backtracking into `is-type`/1: (is-type human)
        8. Failed `is-type`/1: (is-type human)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human human)
       7. Failed `has-subtype*`/2: (has-subtype* human human)
       7. Backtracking into `is-type`/1: (is-type human)
       7. Failed `is-type`/1: (is-type human)
       7. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:5)
       7. Failed `has-subtype`/2: (has-subtype primate ?subtype:5)
       7. Backtracking into `is-type`/1: (is-type human)
       7. Failed `is-type`/1: (is-type human)
      6. Backtracking into `is-type`/1: (is-type primate)
      6. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate human)
     5. Failed `has-subtype*`/2: (has-subtype* primate human)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type human)
     5. Failed `is-type`/1: (is-type human)
    4. Backtracking into `is-type`/1: (is-type mammal)
    4. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal human)
   3. Failed `has-subtype*`/2: (has-subtype* mammal human)
   3. Backtracking into `is-type`/1: (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?x:0)
   3. Failed `is-type`/1: (is-type ?x:0)
  2. Backtracking into `is-type`/1: (is-type vertebrate)
  2. Failed `is-type`/1: (is-type vertebrate)
 1. Backtracking into `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
 1. Failed `has-subtype*`/2: (has-subtype* vertebrate ?x:0)
0. Exhausted query: ((has-subtype* vertebrate ?x))
[mammal primate human]

(do
 (initialize-prolog)
 (assert<- '((is-type vertebrate)))
 (assert<- '((is-type mammal)))
 (assert<- '((is-type primate)))
 (assert<- '((is-type human)))
 (assert<- '((has-subtype vertebrate mammal)))
 (assert<- '((has-subtype mammal primate)))
 (assert<- '((has-subtype primate human)))
 (assert<-
  '((has-subtype* ?type ?subtype) (has-subtype ?type ?subtype)))
 (assert<-
  '((has-subtype* ?type ?subsubtype)
    (is-type ?type)
    (is-type ?subsubtype)
    (truthy? (not= '?type '?subsubtype))
    (has-subtype ?type ?subtype)
    (is-type ?subtype)
    (truthy? (not= '?type '?subtype))
    (has-subtype* ?subtype ?subsubtype))))

(query
 '[?x ?y]
 '((has-subtype* ?x ?y))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype* ?x ?y))
 1. Entering `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
 1. Matched head (has-subtype* ?type:1 ?subtype:1): (has-subtype* ?x:0 ?y:0)
  2. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
  2. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
  2. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
Recorded answer: [vertebrate mammal]
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [mammal primate]
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?y:0)
  2. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [primate human]
  2. Backtracking into `has-subtype`/2: (has-subtype ?x:0 ?y:0)
  2. Failed `has-subtype`/2: (has-subtype ?x:0 ?y:0)
 1. Backtracking into `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
  2. Entering `is-type`/1: (is-type vertebrate)
  2. Matched head (is-type vertebrate): (is-type vertebrate)
  2. Succeeded `is-type`/1: (is-type vertebrate)
   3. Entering `is-type`/1: (is-type vertebrate)
   3. Matched head (is-type vertebrate): (is-type vertebrate)
   3. Succeeded `is-type`/1: (is-type vertebrate)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote vertebrate)))
   (truthy?): Failed (truthy? (not= (quote vertebrate) (quote vertebrate)))
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal mammal)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal mammal)
    4. Entering `has-subtype`/2: (has-subtype mammal mammal)
    4. Failed `has-subtype`/2: (has-subtype mammal mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal mammal)
    4. Entering `is-type`/1: (is-type mammal)
    4. Matched head (is-type mammal): (is-type mammal)
    4. Succeeded `is-type`/1: (is-type mammal)
     5. Entering `is-type`/1: (is-type mammal)
     5. Matched head (is-type mammal): (is-type mammal)
     5. Succeeded `is-type`/1: (is-type mammal)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote mammal)))
     (truthy?): Failed (truthy? (not= (quote mammal) (quote mammal)))
     5. Backtracking into `is-type`/1: (is-type mammal)
     5. Failed `is-type`/1: (is-type mammal)
    4. Backtracking into `is-type`/1: (is-type mammal)
    4. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal mammal)
   3. Failed `has-subtype*`/2: (has-subtype* mammal mammal)
   3. Backtracking into `is-type`/1: (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal primate)
    4. Entering `has-subtype`/2: (has-subtype mammal primate)
    4. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
    4. Succeeded `has-subtype`/2: (has-subtype mammal primate)
Recorded answer: [vertebrate primate]
    4. Backtracking into `has-subtype`/2: (has-subtype mammal primate)
    4. Failed `has-subtype`/2: (has-subtype mammal primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
    4. Entering `is-type`/1: (is-type mammal)
    4. Matched head (is-type mammal): (is-type mammal)
    4. Succeeded `is-type`/1: (is-type mammal)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype`/2: (has-subtype mammal primate)
     5. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
     5. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype*`/2: (has-subtype* primate primate)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate primate)
      6. Entering `has-subtype`/2: (has-subtype primate primate)
      6. Failed `has-subtype`/2: (has-subtype primate primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
      6. Entering `is-type`/1: (is-type primate)
      6. Matched head (is-type primate): (is-type primate)
      6. Succeeded `is-type`/1: (is-type primate)
       7. Entering `is-type`/1: (is-type primate)
       7. Matched head (is-type primate): (is-type primate)
       7. Succeeded `is-type`/1: (is-type primate)
       (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
       (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
       7. Backtracking into `is-type`/1: (is-type primate)
       7. Failed `is-type`/1: (is-type primate)
      6. Backtracking into `is-type`/1: (is-type primate)
      6. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
     5. Failed `has-subtype*`/2: (has-subtype* primate primate)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
    4. Backtracking into `is-type`/1: (is-type mammal)
    4. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal primate)
   3. Failed `has-subtype*`/2: (has-subtype* mammal primate)
   3. Backtracking into `is-type`/1: (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote human)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote human)))
   3. Entering `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Matched head (has-subtype vertebrate mammal): (has-subtype vertebrate mammal)
   3. Succeeded `has-subtype`/2: (has-subtype vertebrate mammal)
   3. Entering `is-type`/1: (is-type mammal)
   3. Matched head (is-type mammal): (is-type mammal)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote vertebrate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote vertebrate) (quote mammal)))
   3. Entering `has-subtype*`/2: (has-subtype* mammal human)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* mammal human)
    4. Entering `has-subtype`/2: (has-subtype mammal human)
    4. Failed `has-subtype`/2: (has-subtype mammal human)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal human)
    4. Entering `is-type`/1: (is-type mammal)
    4. Matched head (is-type mammal): (is-type mammal)
    4. Succeeded `is-type`/1: (is-type mammal)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote human)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote human)))
     5. Entering `has-subtype`/2: (has-subtype mammal primate)
     5. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
     5. Succeeded `has-subtype`/2: (has-subtype mammal primate)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
     (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
     5. Entering `has-subtype*`/2: (has-subtype* primate human)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* primate human)
      6. Entering `has-subtype`/2: (has-subtype primate human)
      6. Matched head (has-subtype primate human): (has-subtype primate human)
      6. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [vertebrate human]
      6. Backtracking into `has-subtype`/2: (has-subtype primate human)
      6. Failed `has-subtype`/2: (has-subtype primate human)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate human)
      6. Entering `is-type`/1: (is-type primate)
      6. Matched head (is-type primate): (is-type primate)
      6. Succeeded `is-type`/1: (is-type primate)
       7. Entering `is-type`/1: (is-type human)
       7. Matched head (is-type human): (is-type human)
       7. Succeeded `is-type`/1: (is-type human)
       (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
       (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
       7. Entering `has-subtype`/2: (has-subtype primate human)
       7. Matched head (has-subtype primate human): (has-subtype primate human)
       7. Succeeded `has-subtype`/2: (has-subtype primate human)
       7. Entering `is-type`/1: (is-type human)
       7. Matched head (is-type human): (is-type human)
       7. Succeeded `is-type`/1: (is-type human)
       (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
       (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
       7. Entering `has-subtype*`/2: (has-subtype* human human)
       7. Matched head (has-subtype* ?type:7 ?subtype:7): (has-subtype* human human)
        8. Entering `has-subtype`/2: (has-subtype human human)
        8. Failed `has-subtype`/2: (has-subtype human human)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human human)
        8. Entering `is-type`/1: (is-type human)
        8. Matched head (is-type human): (is-type human)
        8. Succeeded `is-type`/1: (is-type human)
         9. Entering `is-type`/1: (is-type human)
         9. Matched head (is-type human): (is-type human)
         9. Succeeded `is-type`/1: (is-type human)
         (truthy?): Entering (truthy? (not= (quote human) (quote human)))
         (truthy?): Failed (truthy? (not= (quote human) (quote human)))
         9. Backtracking into `is-type`/1: (is-type human)
         9. Failed `is-type`/1: (is-type human)
        8. Backtracking into `is-type`/1: (is-type human)
        8. Failed `is-type`/1: (is-type human)
       7. Backtracking into `has-subtype*`/2: (has-subtype* human human)
       7. Failed `has-subtype*`/2: (has-subtype* human human)
       7. Backtracking into `is-type`/1: (is-type human)
       7. Failed `is-type`/1: (is-type human)
       7. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:5)
       7. Failed `has-subtype`/2: (has-subtype primate ?subtype:5)
       7. Backtracking into `is-type`/1: (is-type human)
       7. Failed `is-type`/1: (is-type human)
      6. Backtracking into `is-type`/1: (is-type primate)
      6. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* primate human)
     5. Failed `has-subtype*`/2: (has-subtype* primate human)
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
     5. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype mammal ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type human)
     5. Failed `is-type`/1: (is-type human)
    4. Backtracking into `is-type`/1: (is-type mammal)
    4. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* mammal human)
   3. Failed `has-subtype*`/2: (has-subtype* mammal human)
   3. Backtracking into `is-type`/1: (is-type mammal)
   3. Failed `is-type`/1: (is-type mammal)
   3. Backtracking into `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype vertebrate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1: (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type mammal)
   3. Entering `is-type`/1: (is-type vertebrate)
   3. Matched head (is-type vertebrate): (is-type vertebrate)
   3. Succeeded `is-type`/1: (is-type vertebrate)
   (truthy?): Entering (truthy? (not= (quote mammal) (quote vertebrate)))
   (truthy?): Succeeded (truthy? (not= (quote mammal) (quote vertebrate)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate vertebrate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate vertebrate)
    4. Entering `has-subtype`/2: (has-subtype primate vertebrate)
    4. Failed `has-subtype`/2: (has-subtype primate vertebrate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate vertebrate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
     5. Entering `is-type`/1: (is-type vertebrate)
     5. Matched head (is-type vertebrate): (is-type vertebrate)
     5. Succeeded `is-type`/1: (is-type vertebrate)
     (truthy?): Entering (truthy? (not= (quote primate) (quote vertebrate)))
     (truthy?): Succeeded (truthy? (not= (quote primate) (quote vertebrate)))
     5. Entering `has-subtype`/2: (has-subtype primate human)
     5. Matched head (has-subtype primate human): (has-subtype primate human)
     5. Succeeded `has-subtype`/2: (has-subtype primate human)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
     (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
     5. Entering `has-subtype*`/2: (has-subtype* human vertebrate)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* human vertebrate)
      6. Entering `has-subtype`/2: (has-subtype human vertebrate)
      6. Failed `has-subtype`/2: (has-subtype human vertebrate)
     5. Backtracking into `has-subtype*`/2: (has-subtype* human vertebrate)
      6. Entering `is-type`/1: (is-type human)
      6. Matched head (is-type human): (is-type human)
      6. Succeeded `is-type`/1: (is-type human)
       7. Entering `is-type`/1: (is-type vertebrate)
       7. Matched head (is-type vertebrate): (is-type vertebrate)
       7. Succeeded `is-type`/1: (is-type vertebrate)
       (truthy?): Entering (truthy? (not= (quote human) (quote vertebrate)))
       (truthy?): Succeeded (truthy? (not= (quote human) (quote vertebrate)))
       7. Entering `has-subtype`/2: (has-subtype human ?subtype:5)
       7. Failed `has-subtype`/2: (has-subtype human ?subtype:5)
       7. Backtracking into `is-type`/1: (is-type vertebrate)
       7. Failed `is-type`/1: (is-type vertebrate)
      6. Backtracking into `is-type`/1: (is-type human)
      6. Failed `is-type`/1: (is-type human)
     5. Backtracking into `has-subtype*`/2: (has-subtype* human vertebrate)
     5. Failed `has-subtype*`/2: (has-subtype* human vertebrate)
     5. Backtracking into `is-type`/1: (is-type human)
     5. Failed `is-type`/1: (is-type human)
     5. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type vertebrate)
     5. Failed `is-type`/1: (is-type vertebrate)
    4. Backtracking into `is-type`/1: (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate vertebrate)
   3. Failed `has-subtype*`/2: (has-subtype* primate vertebrate)
   3. Backtracking into `is-type`/1: (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote mammal) (quote mammal)))
   (truthy?): Failed (truthy? (not= (quote mammal) (quote mammal)))
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate primate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate primate)
    4. Entering `has-subtype`/2: (has-subtype primate primate)
    4. Failed `has-subtype`/2: (has-subtype primate primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
     5. Entering `is-type`/1: (is-type primate)
     5. Matched head (is-type primate): (is-type primate)
     5. Succeeded `is-type`/1: (is-type primate)
     (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
     (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
     5. Backtracking into `is-type`/1: (is-type primate)
     5. Failed `is-type`/1: (is-type primate)
    4. Backtracking into `is-type`/1: (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate primate)
   3. Failed `has-subtype*`/2: (has-subtype* primate primate)
   3. Backtracking into `is-type`/1: (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote mammal) (quote human)))
   (truthy?): Succeeded (truthy? (not= (quote mammal) (quote human)))
   3. Entering `has-subtype`/2: (has-subtype mammal primate)
   3. Matched head (has-subtype mammal primate): (has-subtype mammal primate)
   3. Succeeded `has-subtype`/2: (has-subtype mammal primate)
   3. Entering `is-type`/1: (is-type primate)
   3. Matched head (is-type primate): (is-type primate)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote mammal) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote mammal) (quote primate)))
   3. Entering `has-subtype*`/2: (has-subtype* primate human)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* primate human)
    4. Entering `has-subtype`/2: (has-subtype primate human)
    4. Matched head (has-subtype primate human): (has-subtype primate human)
    4. Succeeded `has-subtype`/2: (has-subtype primate human)
Recorded answer: [mammal human]
    4. Backtracking into `has-subtype`/2: (has-subtype primate human)
    4. Failed `has-subtype`/2: (has-subtype primate human)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate human)
    4. Entering `is-type`/1: (is-type primate)
    4. Matched head (is-type primate): (is-type primate)
    4. Succeeded `is-type`/1: (is-type primate)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
     (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
     5. Entering `has-subtype`/2: (has-subtype primate human)
     5. Matched head (has-subtype primate human): (has-subtype primate human)
     5. Succeeded `has-subtype`/2: (has-subtype primate human)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
     (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
     5. Entering `has-subtype*`/2: (has-subtype* human human)
     5. Matched head (has-subtype* ?type:5 ?subtype:5): (has-subtype* human human)
      6. Entering `has-subtype`/2: (has-subtype human human)
      6. Failed `has-subtype`/2: (has-subtype human human)
     5. Backtracking into `has-subtype*`/2: (has-subtype* human human)
      6. Entering `is-type`/1: (is-type human)
      6. Matched head (is-type human): (is-type human)
      6. Succeeded `is-type`/1: (is-type human)
       7. Entering `is-type`/1: (is-type human)
       7. Matched head (is-type human): (is-type human)
       7. Succeeded `is-type`/1: (is-type human)
       (truthy?): Entering (truthy? (not= (quote human) (quote human)))
       (truthy?): Failed (truthy? (not= (quote human) (quote human)))
       7. Backtracking into `is-type`/1: (is-type human)
       7. Failed `is-type`/1: (is-type human)
      6. Backtracking into `is-type`/1: (is-type human)
      6. Failed `is-type`/1: (is-type human)
     5. Backtracking into `has-subtype*`/2: (has-subtype* human human)
     5. Failed `has-subtype*`/2: (has-subtype* human human)
     5. Backtracking into `is-type`/1: (is-type human)
     5. Failed `is-type`/1: (is-type human)
     5. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype primate ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type human)
     5. Failed `is-type`/1: (is-type human)
    4. Backtracking into `is-type`/1: (is-type primate)
    4. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* primate human)
   3. Failed `has-subtype*`/2: (has-subtype* primate human)
   3. Backtracking into `is-type`/1: (is-type primate)
   3. Failed `is-type`/1: (is-type primate)
   3. Backtracking into `has-subtype`/2: (has-subtype mammal ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype mammal ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1: (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type primate)
   3. Entering `is-type`/1: (is-type vertebrate)
   3. Matched head (is-type vertebrate): (is-type vertebrate)
   3. Succeeded `is-type`/1: (is-type vertebrate)
   (truthy?): Entering (truthy? (not= (quote primate) (quote vertebrate)))
   (truthy?): Succeeded (truthy? (not= (quote primate) (quote vertebrate)))
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
   (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
   3. Entering `has-subtype*`/2: (has-subtype* human vertebrate)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* human vertebrate)
    4. Entering `has-subtype`/2: (has-subtype human vertebrate)
    4. Failed `has-subtype`/2: (has-subtype human vertebrate)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human vertebrate)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
     5. Entering `is-type`/1: (is-type vertebrate)
     5. Matched head (is-type vertebrate): (is-type vertebrate)
     5. Succeeded `is-type`/1: (is-type vertebrate)
     (truthy?): Entering (truthy? (not= (quote human) (quote vertebrate)))
     (truthy?): Succeeded (truthy? (not= (quote human) (quote vertebrate)))
     5. Entering `has-subtype`/2: (has-subtype human ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype human ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type vertebrate)
     5. Failed `is-type`/1: (is-type vertebrate)
    4. Backtracking into `is-type`/1: (is-type human)
    4. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human vertebrate)
   3. Failed `has-subtype*`/2: (has-subtype* human vertebrate)
   3. Backtracking into `is-type`/1: (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype primate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote primate) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote primate) (quote mammal)))
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
   (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
   3. Entering `has-subtype*`/2: (has-subtype* human mammal)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* human mammal)
    4. Entering `has-subtype`/2: (has-subtype human mammal)
    4. Failed `has-subtype`/2: (has-subtype human mammal)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human mammal)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
     5. Entering `is-type`/1: (is-type mammal)
     5. Matched head (is-type mammal): (is-type mammal)
     5. Succeeded `is-type`/1: (is-type mammal)
     (truthy?): Entering (truthy? (not= (quote human) (quote mammal)))
     (truthy?): Succeeded (truthy? (not= (quote human) (quote mammal)))
     5. Entering `has-subtype`/2: (has-subtype human ?subtype:3)
     5. Failed `has-subtype`/2: (has-subtype human ?subtype:3)
     5. Backtracking into `is-type`/1: (is-type mammal)
     5. Failed `is-type`/1: (is-type mammal)
    4. Backtracking into `is-type`/1: (is-type human)
    4. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human mammal)
   3. Failed `has-subtype*`/2: (has-subtype* human mammal)
   3. Backtracking into `is-type`/1: (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype primate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote primate) (quote primate)))
   (truthy?): Failed (truthy? (not= (quote primate) (quote primate)))
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
   (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
   3. Entering `has-subtype`/2: (has-subtype primate human)
   3. Matched head (has-subtype primate human): (has-subtype primate human)
   3. Succeeded `has-subtype`/2: (has-subtype primate human)
   3. Entering `is-type`/1: (is-type human)
   3. Matched head (is-type human): (is-type human)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote primate) (quote human)))
   (truthy?): Succeeded (truthy? (not= (quote primate) (quote human)))
   3. Entering `has-subtype*`/2: (has-subtype* human human)
   3. Matched head (has-subtype* ?type:3 ?subtype:3): (has-subtype* human human)
    4. Entering `has-subtype`/2: (has-subtype human human)
    4. Failed `has-subtype`/2: (has-subtype human human)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human human)
    4. Entering `is-type`/1: (is-type human)
    4. Matched head (is-type human): (is-type human)
    4. Succeeded `is-type`/1: (is-type human)
     5. Entering `is-type`/1: (is-type human)
     5. Matched head (is-type human): (is-type human)
     5. Succeeded `is-type`/1: (is-type human)
     (truthy?): Entering (truthy? (not= (quote human) (quote human)))
     (truthy?): Failed (truthy? (not= (quote human) (quote human)))
     5. Backtracking into `is-type`/1: (is-type human)
     5. Failed `is-type`/1: (is-type human)
    4. Backtracking into `is-type`/1: (is-type human)
    4. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype*`/2: (has-subtype* human human)
   3. Failed `has-subtype*`/2: (has-subtype* human human)
   3. Backtracking into `is-type`/1: (is-type human)
   3. Failed `is-type`/1: (is-type human)
   3. Backtracking into `has-subtype`/2: (has-subtype primate ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype primate ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1: (is-type ?x:0)
  2. Succeeded `is-type`/1: (is-type human)
   3. Entering `is-type`/1: (is-type vertebrate)
   3. Matched head (is-type vertebrate): (is-type vertebrate)
   3. Succeeded `is-type`/1: (is-type vertebrate)
   (truthy?): Entering (truthy? (not= (quote human) (quote vertebrate)))
   (truthy?): Succeeded (truthy? (not= (quote human) (quote vertebrate)))
   3. Entering `has-subtype`/2: (has-subtype human ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype human ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type mammal)
   (truthy?): Entering (truthy? (not= (quote human) (quote mammal)))
   (truthy?): Succeeded (truthy? (not= (quote human) (quote mammal)))
   3. Entering `has-subtype`/2: (has-subtype human ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype human ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type primate)
   (truthy?): Entering (truthy? (not= (quote human) (quote primate)))
   (truthy?): Succeeded (truthy? (not= (quote human) (quote primate)))
   3. Entering `has-subtype`/2: (has-subtype human ?subtype:1)
   3. Failed `has-subtype`/2: (has-subtype human ?subtype:1)
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Succeeded `is-type`/1: (is-type human)
   (truthy?): Entering (truthy? (not= (quote human) (quote human)))
   (truthy?): Failed (truthy? (not= (quote human) (quote human)))
   3. Backtracking into `is-type`/1: (is-type ?y:0)
   3. Failed `is-type`/1: (is-type ?y:0)
  2. Backtracking into `is-type`/1: (is-type ?x:0)
  2. Failed `is-type`/1: (is-type ?x:0)
 1. Backtracking into `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
 1. Failed `has-subtype*`/2: (has-subtype* ?x:0 ?y:0)
0. Exhausted query: ((has-subtype* ?x ?y))
[[vertebrate mammal]
 [mammal primate]
 [primate human]
 [vertebrate primate]
 [vertebrate human]
 [mammal human]]

(do (initialize-prolog) (assert<- '((successor 0 (s 0)))))

(query '?x '((successor 0 ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((successor 0 ?x))
 1. Entering `successor`/2: (successor 0 (s 0))
 1. Matched head (successor 0 (s 0)): (successor 0 (s 0))
 1. Succeeded `successor`/2: (successor 0 (s 0))
Recorded answer: (s 0)
 1. Backtracking into `successor`/2: (successor 0 ?x:0)
 1. Failed `successor`/2: (successor 0 ?x:0)
0. Exhausted query: ((successor 0 ?x))
[(s 0)]

(do (initialize-prolog) (assert<- '((successor 0 (s 0)))))

(query '?x '((successor ?x (s 0))) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?x (s 0)))
 1. Entering `successor`/2: (successor 0 (s 0))
 1. Matched head (successor 0 (s 0)): (successor 0 (s 0))
 1. Succeeded `successor`/2: (successor 0 (s 0))
Recorded answer: 0
 1. Backtracking into `successor`/2: (successor ?x:0 (s 0))
 1. Failed `successor`/2: (successor ?x:0 (s 0))
0. Exhausted query: ((successor ?x (s 0)))
[0]

(do (initialize-prolog) (assert<- '((successor 0 (s 0)))))

(query '?x '((successor ?x (s ?x))) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?x (s ?x)))
 1. Entering `successor`/2: (successor 0 (s 0))
 1. Matched head (successor 0 (s 0)): (successor 0 (s 0))
 1. Succeeded `successor`/2: (successor 0 (s 0))
Recorded answer: 0
 1. Backtracking into `successor`/2: (successor ?x:0 (s ?x:0))
 1. Failed `successor`/2: (successor ?x:0 (s ?x:0))
0. Exhausted query: ((successor ?x (s ?x)))
[0]

(do
 (initialize-prolog)
 (assert<- '((successor 0 (s 0))))
 (assert<- '((successor (s ?x) (s (s ?x))))))

(query
 '?x
 '((successor ?x (s (s 0))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((successor ?x (s (s 0))))
 1. Entering `successor`/2: (successor (s 0) (s (s 0)))
 1. Matched head (successor (s ?x:1) (s (s ?x:1))): (successor (s 0) (s (s 0)))
 1. Succeeded `successor`/2: (successor (s 0) (s (s 0)))
Recorded answer: (s 0)
 1. Backtracking into `successor`/2: (successor ?x:0 (s (s 0)))
 1. Failed `successor`/2: (successor ?x:0 (s (s 0)))
0. Exhausted query: ((successor ?x (s (s 0))))
[(s 0)]

(do (initialize-prolog) (assert<- '((has-subtype thing ?thing))))

(query
 'true
 '((has-subtype thing mammal))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype thing mammal))
 1. Entering `has-subtype`/2: (has-subtype thing mammal)
 1. Matched head (has-subtype thing ?thing:1): (has-subtype thing mammal)
 1. Succeeded `has-subtype`/2: (has-subtype thing mammal)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((has-subtype thing ?thing))))

(query
 '?bar
 '((has-subtype thing ?bar))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((has-subtype thing ?bar))
 1. Entering `has-subtype`/2: (has-subtype thing ?bar:0)
 1. Matched head (has-subtype thing ?thing:1): (has-subtype thing ?bar:0)
 1. Succeeded `has-subtype`/2: (has-subtype thing ?bar:0)
Recorded answer: ?bar
 1. Backtracking into `has-subtype`/2: (has-subtype thing ?bar:0)
 1. Failed `has-subtype`/2: (has-subtype thing ?bar:0)
0. Exhausted query: ((has-subtype thing ?bar))
[?bar]

(do (initialize-prolog) (assert<- '((successor ?x (s ?x)))))

(query '[?q ?r] '((successor ?q ?r)) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?q ?r))
 1. Entering `successor`/2: (successor ?q:0 (s ?q:0))
 1. Matched head (successor ?x:1 (s ?x:1)): (successor ?q:0 (s ?q:0))
 1. Succeeded `successor`/2: (successor ?q:0 (s ?q:0))
Recorded answer: [?q (s ?q)]
 1. Backtracking into `successor`/2: (successor ?q:0 ?r:0)
 1. Failed `successor`/2: (successor ?q:0 ?r:0)
0. Exhausted query: ((successor ?q ?r))
[[?q (s ?q)]]

(do (initialize-prolog) (assert<- '((successor ?x (s ?x)))))

(query '?r '((successor ?q ?r)) :limit nil :discard-subsumed true)

0. Processing query: ((successor ?q ?r))
 1. Entering `successor`/2: (successor ?q:0 (s ?q:0))
 1. Matched head (successor ?x:1 (s ?x:1)): (successor ?q:0 (s ?q:0))
 1. Succeeded `successor`/2: (successor ?q:0 (s ?q:0))
Recorded answer: (s ?q)
 1. Backtracking into `successor`/2: (successor ?q:0 ?r:0)
 1. Failed `successor`/2: (successor ?q:0 ?r:0)
0. Exhausted query: ((successor ?q ?r))
[(s ?q)]

(do (initialize-prolog) (assert<- '((pseudo-same ?x ?x))))

(query
 '[?q ?r]
 '((pseudo-same ?q ?r))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((pseudo-same ?q ?r))
 1. Entering `pseudo-same`/2: (pseudo-same ?r:0 ?r:0)
 1. Matched head (pseudo-same ?x:1 ?x:1): (pseudo-same ?q:0 ?q:0)
 1. Succeeded `pseudo-same`/2: (pseudo-same ?q:0 ?q:0)
Recorded answer: [?r ?r]
 1. Backtracking into `pseudo-same`/2: (pseudo-same ?q:0 ?r:0)
 1. Failed `pseudo-same`/2: (pseudo-same ?q:0 ?r:0)
0. Exhausted query: ((pseudo-same ?q ?r))
[[?r ?r]]

(do (initialize-prolog) (assert<- '((pseudo-same ?x ?x))))

(query '?x '((pseudo-same ?x ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((pseudo-same ?x ?x))
 1. Entering `pseudo-same`/2: (pseudo-same ?x:0 ?x:0)
 1. Matched head (pseudo-same ?x:1 ?x:1): (pseudo-same ?x:0 ?x:0)
 1. Succeeded `pseudo-same`/2: (pseudo-same ?x:0 ?x:0)
Recorded answer: ?x
 1. Backtracking into `pseudo-same`/2: (pseudo-same ?x:0 ?x:0)
 1. Failed `pseudo-same`/2: (pseudo-same ?x:0 ?x:0)
0. Exhausted query: ((pseudo-same ?x ?x))
[?x]

(do (initialize-prolog) (assert<- '((pseudo-same ?x ?x))))

(query '?x '((same ?x ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((same ?x ?x))
 (same): Entering (same ?x:0 ?x:0)
 (same): Succeeded (same ?x:0 ?x:0)
Recorded answer: ?x
0. Exhausted query: ((same ?x ?x))
[?x]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nephew ?uncle)
    (parent ?nephew ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)
    (male ?nephew)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query '(?x ?y) '((both-male ?x ?y)) :limit nil :discard-subsumed true)

0. Processing query: ((both-male ?x ?y))
 1. Entering `both-male`/2: (both-male ?x:0 ?y:0)
 1. Matched head (both-male ?one:1 ?two:1): (both-male ?x:0 ?y:0)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
   3. Entering `male`/1: (male laban)
   3. Matched head (male laban): (male laban)
   3. Succeeded `male`/1: (male laban)
Recorded answer: (laban laban)
   3. Backtracking into `male`/1: (male ?y:0)
   3. Succeeded `male`/1: (male jacob)
Recorded answer: (laban jacob)
   3. Backtracking into `male`/1: (male ?y:0)
   3. Failed `male`/1: (male ?y:0)
  2. Backtracking into `male`/1: (male ?x:0)
  2. Succeeded `male`/1: (male jacob)
   3. Entering `male`/1: (male laban)
   3. Matched head (male laban): (male laban)
   3. Succeeded `male`/1: (male laban)
Recorded answer: (jacob laban)
   3. Backtracking into `male`/1: (male ?y:0)
   3. Succeeded `male`/1: (male jacob)
Recorded answer: (jacob jacob)
   3. Backtracking into `male`/1: (male ?y:0)
   3. Failed `male`/1: (male ?y:0)
  2. Backtracking into `male`/1: (male ?x:0)
  2. Failed `male`/1: (male ?x:0)
 1. Backtracking into `both-male`/2: (both-male ?x:0 ?y:0)
 1. Failed `both-male`/2: (both-male ?x:0 ?y:0)
0. Exhausted query: ((both-male ?x ?y))
[(laban laban) (laban jacob) (jacob laban) (jacob jacob)]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nephew ?uncle)
    (parent ?nephew ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)
    (male ?nephew)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query
 '?uncle
 '((uncle jacob ?uncle))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((uncle jacob ?uncle))
 1. Entering `uncle`/2: (uncle jacob ?uncle:0)
 1. Matched head (uncle ?nephew:1 ?uncle:1): (uncle jacob ?uncle:0)
  2. Entering `parent`/2: (parent jacob rebecca)
  2. Matched head (parent jacob rebecca): (parent jacob rebecca)
  2. Succeeded `parent`/2: (parent jacob rebecca)
   3. Entering `sibling`/2: (sibling ?uncle:0 rebecca)
   3. Matched head (sibling ?x:3 ?y:3): (sibling ?uncle:0 rebecca)
    4. Entering `brother`/2: (brother ?uncle:0 rebecca)
    4. Failed `brother`/2: (brother ?uncle:0 rebecca)
   3. Backtracking into `sibling`/2: (sibling ?uncle:0 rebecca)
    4. Entering `sister`/2: (sister laban rebecca)
    4. Matched head (sister laban rebecca): (sister laban rebecca)
    4. Succeeded `sister`/2: (sister laban rebecca)
   3. Entering `male`/1: (male laban)
   3. Matched head (male laban): (male laban)
   3. Succeeded `male`/1: (male laban)
   3. Entering `male`/1: (male jacob)
   3. Matched head (male jacob): (male jacob)
   3. Succeeded `male`/1: (male jacob)
Recorded answer: laban
   3. Backtracking into `male`/1: (male jacob)
   3. Failed `male`/1: (male jacob)
   3. Backtracking into `male`/1: (male laban)
   3. Failed `male`/1: (male laban)
    4. Backtracking into `sister`/2: (sister ?uncle:0 rebecca)
    4. Failed `sister`/2: (sister ?uncle:0 rebecca)
   3. Backtracking into `sibling`/2: (sibling ?uncle:0 rebecca)
   3. Failed `sibling`/2: (sibling ?uncle:0 rebecca)
  2. Backtracking into `parent`/2: (parent jacob ?parent:1)
  2. Failed `parent`/2: (parent jacob ?parent:1)
 1. Backtracking into `uncle`/2: (uncle jacob ?uncle:0)
 1. Failed `uncle`/2: (uncle jacob ?uncle:0)
0. Exhausted query: ((uncle jacob ?uncle))
[laban]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nephew ?uncle)
    (parent ?nephew ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)
    (male ?nephew)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query '[?x ?y] '((sibling ?x ?y)) :limit nil :discard-subsumed true)

0. Processing query: ((sibling ?x ?y))
 1. Entering `sibling`/2: (sibling ?x:0 ?y:0)
 1. Matched head (sibling ?x:1 ?y:1): (sibling ?x:0 ?y:0)
  2. Entering `brother`/2: (brother ?x:0 ?y:0)
  2. Failed `brother`/2: (brother ?x:0 ?y:0)
 1. Backtracking into `sibling`/2: (sibling ?x:0 ?y:0)
  2. Entering `sister`/2: (sister laban rebecca)
  2. Matched head (sister laban rebecca): (sister laban rebecca)
  2. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: [laban rebecca]
  2. Backtracking into `sister`/2: (sister ?x:0 ?y:0)
  2. Failed `sister`/2: (sister ?x:0 ?y:0)
 1. Backtracking into `sibling`/2: (sibling ?x:0 ?y:0)
 1. Failed `sibling`/2: (sibling ?x:0 ?y:0)
0. Exhausted query: ((sibling ?x ?y))
[[laban rebecca]]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nephew ?uncle)
    (parent ?nephew ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)
    (male ?nephew)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query '(?x ?y) '((both-male ?x ?y)) :limit 2 :discard-subsumed true)

0. Processing query: ((both-male ?x ?y))
 1. Entering `both-male`/2: (both-male ?x:0 ?y:0)
 1. Matched head (both-male ?one:1 ?two:1): (both-male ?x:0 ?y:0)
  2. Entering `male`/1: (male laban)
  2. Matched head (male laban): (male laban)
  2. Succeeded `male`/1: (male laban)
   3. Entering `male`/1: (male laban)
   3. Matched head (male laban): (male laban)
   3. Succeeded `male`/1: (male laban)
Recorded answer: (laban laban)
   3. Backtracking into `male`/1: (male ?y:0)
   3. Succeeded `male`/1: (male jacob)
Recorded answer: (laban jacob)
Answer limit reached.
[(laban laban) (laban jacob)]

(do
 (initialize-prolog)
 (assert<-
  '((uncle ?nephew ?uncle)
    (parent ?nephew ?parent)
    (sibling ?uncle ?parent)
    (male ?uncle)
    (male ?nephew)))
 (assert<- '((sibling ?x ?y) (brother ?x ?y)))
 (assert<- '((sibling ?x ?y) (sister ?x ?y)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((male laban)))
 (assert<- '((male jacob)))
 (assert<- '((parent jacob rebecca)))
 (assert<- '((both-male ?one ?two) (male ?one) (male ?two))))

(query
 '?uncle
 '((sister ?uncle rebecca) (male ?uncle))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((sister ?uncle rebecca) (male ?uncle))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
Recorded answer: laban
 1. Backtracking into `male`/1: (male laban)
 1. Failed `male`/1: (male laban)
 1. Backtracking into `sister`/2: (sister ?uncle:0 rebecca)
 1. Failed `sister`/2: (sister ?uncle:0 rebecca)
0. Exhausted query: ((sister ?uncle rebecca) (male ?uncle))
[laban]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister ?x ?y))))

(query '[?x ?y] '((sister ?x ?y)) :limit nil :discard-subsumed true)

0. Processing query: ((sister ?x ?y))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: [laban rebecca]
 1. Backtracking into `sister`/2: (sister ?x:0 ?y:0)
 1. Succeeded `sister`/2: (sister ?x:0 ?y:0)
Recorded subsuming answer (discarded 1 subsumed answer(s)):  [?x ?y]
 1. Backtracking into `sister`/2: (sister ?x:0 ?y:0)
 1. Failed `sister`/2: (sister ?x:0 ?y:0)
0. Exhausted query: ((sister ?x ?y))
[[?x ?y]]

(do (initialize-prolog) (assert<- '((treasure (buried ?x)))))

(query '?r '((treasure ?r)) :limit nil :discard-subsumed true)

0. Processing query: ((treasure ?r))
 1. Entering `treasure`/1: (treasure (buried ?x:1))
 1. Matched head (treasure (buried ?x:1)): (treasure (buried ?x:1))
 1. Succeeded `treasure`/1: (treasure (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `treasure`/1: (treasure ?r:0)
 1. Failed `treasure`/1: (treasure ?r:0)
0. Exhausted query: ((treasure ?r))
[(buried ?unbound-0)]

(do
 (initialize-prolog)
 (assert<- '((treasure (buried ?x))))
 (assert<- '((marks-the-spot X))))

(query
 '[?r ?x]
 '((treasure ?r) (marks-the-spot ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((treasure ?r) (marks-the-spot ?x))
 1. Entering `treasure`/1: (treasure (buried ?x:1))
 1. Matched head (treasure (buried ?x:1)): (treasure (buried ?x:1))
 1. Succeeded `treasure`/1: (treasure (buried ?x:1))
 1. Entering `marks-the-spot`/1: (marks-the-spot X)
 1. Matched head (marks-the-spot X): (marks-the-spot X)
 1. Succeeded `marks-the-spot`/1: (marks-the-spot X)
Recorded answer: [(buried ?unbound-0) X]
 1. Backtracking into `marks-the-spot`/1: (marks-the-spot ?x:0)
 1. Failed `marks-the-spot`/1: (marks-the-spot ?x:0)
 1. Backtracking into `treasure`/1: (treasure ?r:0)
 1. Failed `treasure`/1: (treasure ?r:0)
0. Exhausted query: ((treasure ?r) (marks-the-spot ?x))
[[(buried ?unbound-0) X]]

(do (initialize-prolog) (assert<- '(("treasure" (buried ?x)))))

(query '?r '(("treasure" ?r)) :limit nil :discard-subsumed true)

0. Processing query: (("treasure" ?r))
 1. Entering `"treasure"`/1: ("treasure" (buried ?x:1))
 1. Matched head ("treasure" (buried ?x:1)): ("treasure" (buried ?x:1))
 1. Succeeded `"treasure"`/1: ("treasure" (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `"treasure"`/1: ("treasure" ?r:0)
 1. Failed `"treasure"`/1: ("treasure" ?r:0)
0. Exhausted query: (("treasure" ?r))
[(buried ?unbound-0)]

(do (initialize-prolog) (assert<- '(([treasure] (buried ?x)))))

(query '?r '(([treasure] ?r)) :limit nil :discard-subsumed true)

0. Processing query: (([treasure] ?r))
 1. Entering `[treasure]`/1: ([treasure] (buried ?x:1))
 1. Matched head ([treasure] (buried ?x:1)): ([treasure] (buried ?x:1))
 1. Succeeded `[treasure]`/1: ([treasure] (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `[treasure]`/1: ([treasure] ?r:0)
 1. Failed `[treasure]`/1: ([treasure] ?r:0)
0. Exhausted query: (([treasure] ?r))
[(buried ?unbound-0)]

(do (initialize-prolog) (assert<- '(([treasure chest] (buried ?x)))))

(query '?r '(([treasure ?thing] ?r)) :limit nil :discard-subsumed true)

0. Processing query: (([treasure ?thing] ?r))
 1. Entering `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
 1. Matched head ([treasure chest] (buried ?x:1)): ([treasure chest] (buried ?x:1))
 1. Succeeded `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
Recorded answer: (buried ?unbound-0)
 1. Backtracking into `[treasure ?thing:0]`/1: ([treasure ?thing:0] ?r:0)
 1. Failed `[treasure ?thing:0]`/1: ([treasure ?thing:0] ?r:0)
0. Exhausted query: (([treasure ?thing] ?r))
[(buried ?unbound-0)]

(do (initialize-prolog) (assert<- '(([treasure chest] (buried ?x)))))

(query
 '[?r ?thing]
 '(([treasure ?thing] ?r))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: (([treasure ?thing] ?r))
 1. Entering `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
 1. Matched head ([treasure chest] (buried ?x:1)): ([treasure chest] (buried ?x:1))
 1. Succeeded `[treasure chest]`/1: ([treasure chest] (buried ?x:1))
Recorded answer: [(buried ?unbound-0) chest]
 1. Backtracking into `[treasure ?thing:0]`/1: ([treasure ?thing:0] ?r:0)
 1. Failed `[treasure ?thing:0]`/1: ([treasure ?thing:0] ?r:0)
0. Exhausted query: (([treasure ?thing] ?r))
[[(buried ?unbound-0) chest]]

(do (initialize-prolog) (assert<- '((male jacob))))

(query '?pred '((?pred jacob)) :limit nil :discard-subsumed true)

0. Processing query: ((?pred jacob))
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Recorded answer: male
 1. Backtracking into `?pred:0`/1: (?pred:0 jacob)
 1. Failed `?pred:0`/1: (?pred:0 jacob)
0. Exhausted query: ((?pred jacob))
[male]

(do
 (initialize-prolog)
 (assert<- '((male jacob)))
 (assert<- '((goal (male ?male)))))

(query '?goal '((goal ?goal) ?goal) :limit nil :discard-subsumed true)

0. Processing query: ((goal ?goal) ?goal)
 1. Entering `goal`/1: (goal (male ?male:1))
 1. Matched head (goal (male ?male:1)): (goal (male ?male:1))
 1. Succeeded `goal`/1: (goal (male ?male:1))
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Recorded answer: (male jacob)
 1. Backtracking into `male`/1: (male ?unbound-0:0)
 1. Failed `male`/1: (male ?unbound-0:0)
 1. Backtracking into `goal`/1: (goal ?goal:0)
 1. Failed `goal`/1: (goal ?goal:0)
0. Exhausted query: ((goal ?goal) ?goal)
[(male jacob)]

(do (initialize-prolog) (assert<- '((male jacob))))

(query '?goal '(?goal) :limit nil :discard-subsumed true)

0. Processing query: (?goal)
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Recorded answer: (male jacob)
 1. Backtracking into `[:index 0]`/1: ?goal:0
 1. Failed `[:index 0]`/1: ?goal:0
0. Exhausted query: (?goal)
[(male jacob)]

(do (initialize-prolog))

(query 'true '((and)) :limit nil :discard-subsumed true)

0. Processing query: ((and))
 (and): Entering (and)
 (and): Succeeded (and)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((and (pseudo-fail))) :limit nil :discard-subsumed true)

0. Processing query: ((and (pseudo-fail)))
 (and): Entering (and (pseudo-fail))
  1. Entering `pseudo-fail`/0: (pseudo-fail)
  1. Failed `pseudo-fail`/0: (pseudo-fail)
 (and): Failed (and (pseudo-fail))
0. Exhausted query: ((and (pseudo-fail)))
[]

(do (initialize-prolog))

(query 'true '((and) (and)) :limit nil :discard-subsumed true)

0. Processing query: ((and) (and))
 (and): Entering (and)
 (and): Succeeded (and)
 (and): Entering (and)
 (and): Succeeded (and)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((and (and))) :limit nil :discard-subsumed true)

0. Processing query: ((and (and)))
 (and): Entering (and (and))
  (and and): Entering (and)
  (and and): Succeeded (and)
 (and): Succeeded (and (and))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((and (and (and)))) :limit nil :discard-subsumed true)

0. Processing query: ((and (and (and))))
 (and): Entering (and (and (and)))
  (and and): Entering (and (and))
   (and and and): Entering (and)
   (and and and): Succeeded (and)
  (and and): Succeeded (and (and))
 (and): Succeeded (and (and (and)))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query 'true '((and (male ?x))) :limit nil :discard-subsumed true)

0. Processing query: ((and (male ?x)))
 (and): Entering (and (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 (and): Succeeded (and (male laban))
Recorded answer: true
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (and): Failed (and (male ?x:0))
0. Exhausted query: ((and (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query 'true '((and) (male ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((and) (male ?x))
 (and): Entering (and)
 (and): Succeeded (and)
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
Recorded answer: true
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
 (and): Failed (and)
0. Exhausted query: ((and) (male ?x))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((and (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (male ?x)))
 (and): Entering (and (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 (and): Succeeded (and (male laban) (male laban))
Recorded answer: true
  1. Backtracking into `male`/1: (male laban)
  1. Failed `male`/1: (male laban)
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (and): Failed (and (male ?x:0) (male ?x:0))
0. Exhausted query: ((and (male ?x) (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((and (male ?x) (female ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (female ?x)))
 (and): Entering (and (male ?x:0) (female ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  1. Entering `female`/1: (female laban)
  1. Failed `female`/1: (female laban)
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (and): Failed (and (male ?x:0) (female ?x:0))
0. Exhausted query: ((and (male ?x) (female ?x)))
[]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((and (male ?x) (and (male ?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (and (male ?x))))
 (and): Entering (and (male ?x:0) (and (male ?x:0)))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  (and and): Entering (and (male laban))
   1. Entering `male`/1: (male laban)
   1. Matched head (male laban): (male laban)
   1. Succeeded `male`/1: (male laban)
  (and and): Succeeded (and (male laban))
 (and): Succeeded (and (male laban) (and (male laban)))
Recorded answer: true
   1. Backtracking into `male`/1: (male laban)
   1. Failed `male`/1: (male laban)
  (and and): Failed (and (male laban))
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (and): Failed (and (male ?x:0) (and (male ?x:0)))
0. Exhausted query: ((and (male ?x) (and (male ?x))))
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 'true
 '((and (male ?x) (male ?y)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (male ?y)))
 (and): Entering (and (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 (and): Succeeded (and (male laban) (male laban))
Recorded answer: true
  1. Backtracking into `male`/1: (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
 (and): Succeeded (and (male laban) (male jacob))
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1: (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
 (and): Succeeded (and (male jacob) (male laban))
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1: (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
 (and): Succeeded (and (male jacob) (male jacob))
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1: (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (and): Failed (and (male ?x:0) (male ?y:0))
0. Exhausted query: ((and (male ?x) (male ?y)))
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or)) :limit nil :discard-subsumed true)

0. Processing query: ((or))
 (or): Entering (or)
 (or): Failed (or)
0. Exhausted query: ((or))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or (pseudo-fail))) :limit nil :discard-subsumed true)

0. Processing query: ((or (pseudo-fail)))
 (or): Entering (or (pseudo-fail))
  1. Entering `pseudo-fail`/0: (pseudo-fail)
  1. Failed `pseudo-fail`/0: (pseudo-fail)
 (or): Failed (or (pseudo-fail))
0. Exhausted query: ((or (pseudo-fail)))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or (pseudo-succeed))) :limit nil :discard-subsumed true)

0. Processing query: ((or (pseudo-succeed)))
 (or): Entering (or (pseudo-succeed))
  1. Entering `pseudo-succeed`/0: (pseudo-succeed)
  1. Matched head (pseudo-succeed): (pseudo-succeed)
  1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((or (pseudo-fail) (pseudo-succeed)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (pseudo-fail) (pseudo-succeed)))
 (or): Entering (or (pseudo-fail) (pseudo-succeed))
  1. Entering `pseudo-fail`/0: (pseudo-fail)
  1. Failed `pseudo-fail`/0: (pseudo-fail)
 (or): Backtracking into (or (pseudo-fail) (pseudo-succeed))
  1. Entering `pseudo-succeed`/0: (pseudo-succeed)
  1. Matched head (pseudo-succeed): (pseudo-succeed)
  1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((clolog.core/or (pseudo-fail) (pseudo-succeed)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((clolog.core/or (pseudo-fail) (pseudo-succeed)))
 1. Entering `clolog.core/or`/2: (clolog.core/or (pseudo-fail) (pseudo-succeed))
 1. Failed `clolog.core/or`/2: (clolog.core/or (pseudo-fail) (pseudo-succeed))
0. Exhausted query: ((clolog.core/or (pseudo-fail) (pseudo-succeed)))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((clojure.core/or (pseudo-fail) (pseudo-succeed)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((clojure.core/or (pseudo-fail) (pseudo-succeed)))
 1. Entering `clojure.core/or`/2: (clojure.core/or (pseudo-fail) (pseudo-succeed))
 1. Failed `clojure.core/or`/2: (clojure.core/or (pseudo-fail) (pseudo-succeed))
0. Exhausted query: ((clojure.core/or (pseudo-fail) (pseudo-succeed)))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query 'true '((or) (or)) :limit nil :discard-subsumed true)

0. Processing query: ((or) (or))
 (or): Entering (or)
 (or): Failed (or)
0. Exhausted query: ((or) (or))
[]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((or (or (pseudo-succeed))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (or (pseudo-succeed))))
 (or): Entering (or (or (pseudo-succeed)))
  (or or): Entering (or (pseudo-succeed))
   1. Entering `pseudo-succeed`/0: (pseudo-succeed)
   1. Matched head (pseudo-succeed): (pseudo-succeed)
   1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((pseudo-succeed))))

(query
 'true
 '((or (or (or (pseudo-succeed)))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (or (or (pseudo-succeed)))))
 (or): Entering (or (or (or (pseudo-succeed))))
  (or or): Entering (or (or (pseudo-succeed)))
   (or or or): Entering (or (pseudo-succeed))
    1. Entering `pseudo-succeed`/0: (pseudo-succeed)
    1. Matched head (pseudo-succeed): (pseudo-succeed)
    1. Succeeded `pseudo-succeed`/0: (pseudo-succeed)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query 'true '((or (male ?x))) :limit nil :discard-subsumed true)

0. Processing query: ((or (male ?x)))
 (or): Entering (or (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Failed (or (male ?x:0))
0. Exhausted query: ((or (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((or (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?x)))
 (or): Entering (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Failed (or (male ?x:0) (male ?x:0))
0. Exhausted query: ((or (male ?x) (male ?x)))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((or (male ?x) (or (male ?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (or (male ?x))))
 (or): Entering (or (male ?x:0) (or (male ?x:0)))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (or (male ?x:0)))
  (or or): Entering (or (male ?x:0))
   1. Entering `male`/1: (male laban)
   1. Matched head (male laban): (male laban)
   1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): true
   1. Backtracking into `male`/1: (male ?x:0)
   1. Failed `male`/1: (male ?x:0)
  (or or): Failed (or (male ?x:0))
 (or): Failed (or (male ?x:0) (or (male ?x:0)))
0. Exhausted query: ((or (male ?x) (or (male ?x))))
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '?x
 '((or (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?x)))
 (or): Entering (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: laban
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: jacob
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): laban
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): jacob
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Failed (or (male ?x:0) (male ?x:0))
0. Exhausted query: ((or (male ?x) (male ?x)))
[laban jacob]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '?y
 '((or (male ?x) (male ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?x)))
 (or): Entering (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: ?y
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): ?y
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (male ?x:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): ?y
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): ?y
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Failed (or (male ?x:0) (male ?x:0))
0. Exhausted query: ((or (male ?x) (male ?x)))
[?y]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 'true
 '((or (male ?x) (male ?y)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?y)))
 (or): Entering (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: true
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1: (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): true
  1. Backtracking into `male`/1: (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
 (or): Failed (or (male ?x:0) (male ?y:0))
0. Exhausted query: ((or (male ?x) (male ?y)))
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '[?x ?y]
 '((or (male ?x) (male ?y)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?y)))
 (or): Entering (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [laban ?y]
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [jacob ?y]
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (male ?y:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [?x laban]
  1. Backtracking into `male`/1: (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [?x jacob]
  1. Backtracking into `male`/1: (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
 (or): Failed (or (male ?x:0) (male ?y:0))
0. Exhausted query: ((or (male ?x) (male ?y)))
[[laban ?y] [jacob ?y] [?x laban] [?x jacob]]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '[?x ?y]
 '((or (male ?x) (male ?y) (male ?z)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male ?x) (male ?y) (male ?z)))
 (or): Entering (or (male ?x:0) (male ?y:0) (male ?z:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [laban ?y]
  1. Backtracking into `male`/1: (male ?x:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [jacob ?y]
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male ?x:0) (male ?y:0) (male ?z:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: [?x laban]
  1. Backtracking into `male`/1: (male ?y:0)
  1. Succeeded `male`/1: (male jacob)
Recorded answer: [?x jacob]
  1. Backtracking into `male`/1: (male ?y:0)
  1. Failed `male`/1: (male ?y:0)
 (or): Backtracking into (or (male ?x:0) (male ?y:0) (male ?z:0))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded subsuming answer (discarded 4 subsumed answer(s)):  [?x ?y]
  1. Backtracking into `male`/1: (male ?z:0)
  1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): [?x ?y]
  1. Backtracking into `male`/1: (male ?z:0)
  1. Failed `male`/1: (male ?z:0)
 (or): Failed (or (male ?x:0) (male ?y:0) (male ?z:0))
0. Exhausted query: ((or (male ?x) (male ?y) (male ?z)))
[[?x ?y]]

(do (initialize-prolog))

(query 'true '((true)) :limit nil :discard-subsumed true)

0. Processing query: ((true))
 (true): Entering (true)
 (true): Succeeded (true)
Recorded answer: true
Answer limit reached.
[true]

(do
 (initialize-prolog)
 (assert<- '((male laban)))
 (assert<- '((male jacob))))

(query
 '[laban jacob]
 '((male ?x) (true) (male ?x))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (true) (male ?x))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (true): Entering (true)
 (true): Succeeded (true)
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
Recorded answer: [laban jacob]
 1. Backtracking into `male`/1: (male laban)
 1. Failed `male`/1: (male laban)
 1. Backtracking into `male`/1: (male ?x:0)
 1. Succeeded `male`/1: (male jacob)
 (true): Entering (true)
 (true): Succeeded (true)
 1. Entering `male`/1: (male jacob)
 1. Matched head (male jacob): (male jacob)
 1. Succeeded `male`/1: (male jacob)
Duplicate answer (not recorded): [laban jacob]
 1. Backtracking into `male`/1: (male jacob)
 1. Failed `male`/1: (male jacob)
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (true) (male ?x))
[[laban jacob]]

(do (initialize-prolog))

(query 'true '((false)) :limit nil :discard-subsumed true)

0. Processing query: ((false))
 (false): Entering (false)
 (false): Failed (false)
0. Exhausted query: ((false))
[]

(do (initialize-prolog))

(query 'true '((truthy? true)) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? true))
 (truthy?): Entering (truthy? true)
 (truthy?): Succeeded (truthy? true)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((truthy? (+ 1 2))) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? (+ 1 2)))
 (truthy?): Entering (truthy? (+ 1 2))
 (truthy?): Succeeded (truthy? (+ 1 2))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((truthy? true) (true)) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? true) (true))
 (truthy?): Entering (truthy? true)
 (truthy?): Succeeded (truthy? true)
 (true): Entering (true)
 (true): Succeeded (true)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((male ?x) (truthy? (list '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (truthy? (list (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (truthy?): Entering (truthy? (list (quote laban)))
 (truthy?): Succeeded (truthy? (list (quote laban)))
Recorded answer: laban
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (truthy? (list (quote ?x))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?y
 '((male ?x) (evals-from? ?y (list '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? ?y (list (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (evals-from?): Entering (evals-from? ?y:0 (list (quote laban)))
 (evals-from?): Succeeded (evals-from? (laban) (list (quote laban)))
Recorded answer: (laban)
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? ?y (list (quote ?x))))
[(laban)]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((and (male ?x) (truthy? (list '?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (male ?x) (truthy? (list (quote ?x)))))
 (and): Entering (and (male ?x:0) (truthy? (list (quote ?x:0))))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
  (and truthy?): Entering (truthy? (list (quote laban)))
  (and truthy?): Succeeded (truthy? (list (quote laban)))
 (and): Succeeded (and (male laban) (truthy? (list (quote laban))))
Recorded answer: laban
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (and): Failed (and (male ?x:0) (truthy? (list (quote ?x:0))))
0. Exhausted query: ((and (male ?x) (truthy? (list (quote ?x)))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((male ?x) (truthy? (= '?x 'laban)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (truthy? (= (quote ?x) (quote laban))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (truthy?): Entering (truthy? (= (quote laban) (quote laban)))
 (truthy?): Succeeded (truthy? (= (quote laban) (quote laban)))
Recorded answer: laban
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (truthy? (= (quote ?x) (quote laban))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query '?x '((male ?x) (truthy? nil)) :limit nil :discard-subsumed true)

0. Processing query: ((male ?x) (truthy? nil))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (truthy?): Entering (truthy? nil)
 (truthy?): Failed (truthy? nil)
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (truthy? nil))
[]

(do (initialize-prolog) (assert<- '((male laban))))

(query '?x '((truthy? ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((truthy? ?x))
 (truthy?): Entering (truthy? ?x:0)
 (truthy?): Failed, not ground (truthy? ?x:0)
0. Exhausted query: ((truthy? ?x))
[]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?x
 '((or (male leah) (male ?x) (truthy? (list '?x))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (male leah) (male ?x) (truthy? (list (quote ?x)))))
 (or): Entering (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
  1. Entering `male`/1: (male leah)
  1. Failed `male`/1: (male leah)
 (or): Backtracking into (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
  1. Entering `male`/1: (male laban)
  1. Matched head (male laban): (male laban)
  1. Succeeded `male`/1: (male laban)
Recorded answer: laban
  1. Backtracking into `male`/1: (male ?x:0)
  1. Failed `male`/1: (male ?x:0)
 (or): Backtracking into (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
  (or truthy?): Entering (truthy? (list (quote ?x:0)))
  (or truthy?): Failed, not ground (truthy? (list (quote ?x:0)))
 (or): Failed (or (male leah) (male ?x:0) (truthy? (list (quote ?x:0))))
0. Exhausted query: ((or (male leah) (male ?x) (truthy? (list (quote ?x)))))
[laban]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?message
 '((male ?x) (evals-from? ?message (str "Hello, " '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? ?message (str "Hello, " (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (evals-from?): Entering (evals-from? ?message:0 (str "Hello, " (quote laban)))
 (evals-from?): Succeeded (evals-from? "Hello, laban" (str "Hello, " (quote laban)))
Recorded answer: Hello, laban
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? ?message (str "Hello, " (quote ?x))))
["Hello, laban"]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 'true
 '((male ?x) (do (clojure.pprint/cl-format nil "Hello, ~a." '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (do (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (do): Entering (do (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
 (do): Succeeded (do (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
Recorded answer: true
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (do (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
[true]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?message
 '((male ?x)
   (evals-from?
    ?message
    (clojure.pprint/cl-format nil "Hello, ~a." '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? ?message (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (evals-from?): Entering (evals-from? ?message:0 (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
 (evals-from?): Succeeded (evals-from? "Hello, laban." (clojure.pprint/cl-format nil "Hello, ~a." (quote laban)))
Recorded answer: Hello, laban.
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? ?message (clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))))
["Hello, laban."]

(do (initialize-prolog) (assert<- '((male laban))))

(query
 '?message
 '((male ?x)
   (evals-from?
    [?message]
    [(clojure.pprint/cl-format nil "Hello, ~a." '?x)]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((male ?x) (evals-from? [?message] [(clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))]))
 1. Entering `male`/1: (male laban)
 1. Matched head (male laban): (male laban)
 1. Succeeded `male`/1: (male laban)
 (evals-from?): Entering (evals-from? [?message:0] [(clojure.pprint/cl-format nil "Hello, ~a." (quote laban))])
 (evals-from?): Succeeded (evals-from? ["Hello, laban."] [(clojure.pprint/cl-format nil "Hello, ~a." (quote laban))])
Recorded answer: Hello, laban.
 1. Backtracking into `male`/1: (male ?x:0)
 1. Failed `male`/1: (male ?x:0)
0. Exhausted query: ((male ?x) (evals-from? [?message] [(clojure.pprint/cl-format nil "Hello, ~a." (quote ?x))]))
["Hello, laban."]

(do (initialize-prolog))

(query
 '[?a ?b]
 '((same [?a 2] [1 ?b]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same [?a 2] [1 ?b]))
 (same): Entering (same [?a:0 2] [1 ?b:0])
 (same): Succeeded (same [1 2] [1 2])
Recorded answer: [1 2]
0. Exhausted query: ((same [?a 2] [1 ?b]))
[[1 2]]

(do (initialize-prolog))

(query
 '(?a ?b)
 '((same [?a 2] [1 ?b]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same [?a 2] [1 ?b]))
 (same): Entering (same [?a:0 2] [1 ?b:0])
 (same): Succeeded (same [1 2] [1 2])
Recorded answer: (1 2)
0. Exhausted query: ((same [?a 2] [1 ?b]))
[(1 2)]

(do (initialize-prolog))

(query 'true '((not (truthy? false))) :limit nil :discard-subsumed true)

0. Processing query: ((not (truthy? false)))
 (not): Entering (not (truthy? false))
  (not truthy?): Entering (truthy? false)
  (not truthy?): Failed (truthy? false)
 (not): Succeeded (not (truthy? false))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 'true
 '((not (brother laban rebecca)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((not (brother laban rebecca)))
 (not): Entering (not (brother laban rebecca))
  1. Entering `brother`/2: (brother laban rebecca)
  1. Failed `brother`/2: (brother laban rebecca)
 (not): Succeeded (not (brother laban rebecca))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '((sister laban rebecca))))

(query
 '[?x ?y]
 '((sister ?x ?y) (not (sister ?y ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((sister ?x ?y) (not (sister ?y ?x)))
 1. Entering `sister`/2: (sister laban rebecca)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
 (not): Entering (not (sister rebecca laban))
  1. Entering `sister`/2: (sister rebecca laban)
  1. Failed `sister`/2: (sister rebecca laban)
 (not): Succeeded (not (sister rebecca laban))
Recorded answer: [laban rebecca]
 1. Backtracking into `sister`/2: (sister ?x:0 ?y:0)
 1. Failed `sister`/2: (sister ?x:0 ?y:0)
0. Exhausted query: ((sister ?x ?y) (not (sister ?y ?x)))
[[laban rebecca]]

(do (initialize-prolog))

(query
 '?x
 '((and (evals-from? ?x true) (truthy? '?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (evals-from? ?x true) (truthy? (quote ?x))))
 (and): Entering (and (evals-from? ?x:0 true) (truthy? (quote ?x:0)))
  (and evals-from?): Entering (evals-from? ?x:0 true)
  (and evals-from?): Succeeded (evals-from? true true)
  (and truthy?): Entering (truthy? (quote true))
  (and truthy?): Succeeded (truthy? (quote true))
 (and): Succeeded (and (evals-from? true true) (truthy? (quote true)))
Recorded answer: true
 (and): Failed (and (evals-from? ?x:0 true) (truthy? (quote ?x:0)))
0. Exhausted query: ((and (evals-from? ?x true) (truthy? (quote ?x))))
[true]

(do (initialize-prolog))

(query
 '?x
 '((and (evals-from? ?x true) (truthy? ?x)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (evals-from? ?x true) (truthy? ?x)))
 (and): Entering (and (evals-from? ?x:0 true) (truthy? ?x:0))
  (and evals-from?): Entering (evals-from? ?x:0 true)
  (and evals-from?): Succeeded (evals-from? true true)
  (and truthy?): Entering (truthy? true)
  (and truthy?): Succeeded (truthy? true)
 (and): Succeeded (and (evals-from? true true) (truthy? true))
Recorded answer: true
 (and): Failed (and (evals-from? ?x:0 true) (truthy? ?x:0))
0. Exhausted query: ((and (evals-from? ?x true) (truthy? ?x)))
[true]

(do (initialize-prolog))

(query
 'true
 '((if (true) (true) (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (true) (true) (true)))
 (if): Entering (if (true) (true) (true))
 (if): Checking 'if' condition (if (true) (true) (true))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Taking 'then' branch of (if (true) (true) (true))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Succeeded (if (true) (true) (true))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 'true
 '((if (truthy? true) (true) (false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (truthy? true) (true) (false)))
 (if): Entering (if (truthy? true) (true) (false))
 (if): Checking 'if' condition (if (truthy? true) (true) (false))
  (if truthy?): Entering (truthy? true)
  (if truthy?): Succeeded (truthy? true)
 (if): Taking 'then' branch of (if (truthy? true) (true) (false))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Succeeded (if (truthy? true) (true) (false))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 '?x
 '((if (true) (evals-from? ?x true) (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (true) (evals-from? ?x true) (evals-from? ?x false)))
 (if): Entering (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking 'if' condition (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Taking 'then' branch of (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 true)
  (if evals-from?): Succeeded (evals-from? true true)
 (if): Succeeded (if (true) (evals-from? true true) (evals-from? true false))
Recorded answer: true
 (if): Failed (if (true) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (true) (evals-from? ?x true) (evals-from? ?x false)))
[true]

(do (initialize-prolog))

(query
 '?x
 '((if (false) (evals-from? ?x true) (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (false) (evals-from? ?x true) (evals-from? ?x false)))
 (if): Entering (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking 'if' condition (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if false): Entering (false)
  (if false): Failed (false)
 (if): Taking 'else' branch of (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 false)
  (if evals-from?): Succeeded (evals-from? false false)
 (if): Succeeded (if (false) (evals-from? false true) (evals-from? false false))
Recorded answer: false
 (if): Failed (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (false) (evals-from? ?x true) (evals-from? ?x false)))
[false]

(do (initialize-prolog))

(query
 '?x
 '((if
    (false)
    (evals-from? ?x true)
    (if (false) (evals-from? ?x true) (evals-from? ?x false))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (false) (evals-from? ?x true) (if (false) (evals-from? ?x true) (evals-from? ?x false))))
 (if): Entering (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
 (if): Checking 'if' condition (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
  (if false): Entering (false)
  (if false): Failed (false)
 (if): Taking 'else' branch of (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
  (if if): Entering (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if if): Checking 'if' condition (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
   (if if false): Entering (false)
   (if if false): Failed (false)
  (if if): Taking 'else' branch of (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
   (if if evals-from?): Entering (evals-from? ?x:0 false)
   (if if evals-from?): Succeeded (evals-from? false false)
  (if if): Succeeded (if (false) (evals-from? false true) (evals-from? false false))
 (if): Succeeded (if (false) (evals-from? false true) (if (false) (evals-from? false true) (evals-from? false false)))
Recorded answer: false
  (if if): Failed (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Failed (if (false) (evals-from? ?x:0 true) (if (false) (evals-from? ?x:0 true) (evals-from? ?x:0 false)))
0. Exhausted query: ((if (false) (evals-from? ?x true) (if (false) (evals-from? ?x true) (evals-from? ?x false))))
[false]

(do (initialize-prolog))

(query
 '?x
 '((if
    (true)
    (if
     (false)
     (evals-from? ?x :inner-then)
     (evals-from? ?x :inner-else))
    (evals-from? ?x :outer-else)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (true) (if (false) (evals-from? ?x :inner-then) (evals-from? ?x :inner-else)) (evals-from? ?x :outer-else)))
 (if): Entering (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
 (if): Checking 'if' condition (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Taking 'then' branch of (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
  (if if): Entering (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
  (if if): Checking 'if' condition (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
   (if if false): Entering (false)
   (if if false): Failed (false)
  (if if): Taking 'else' branch of (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
   (if if evals-from?): Entering (evals-from? ?x:0 :inner-else)
   (if if evals-from?): Succeeded (evals-from? :inner-else :inner-else)
  (if if): Succeeded (if (false) (evals-from? :inner-else :inner-then) (evals-from? :inner-else :inner-else))
 (if): Succeeded (if (true) (if (false) (evals-from? :inner-else :inner-then) (evals-from? :inner-else :inner-else)) (evals-from? :inner-else :outer-else))
Recorded answer: :inner-else
  (if if): Failed (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else))
 (if): Failed (if (true) (if (false) (evals-from? ?x:0 :inner-then) (evals-from? ?x:0 :inner-else)) (evals-from? ?x:0 :outer-else))
0. Exhausted query: ((if (true) (if (false) (evals-from? ?x :inner-then) (evals-from? ?x :inner-else)) (evals-from? ?x :outer-else)))
[:inner-else]

(do (initialize-prolog) (assert<- '((sister laban rebecca))))

(query
 '?x
 '((if
    (sister laban rebecca)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (sister laban rebecca) (evals-from? ?x true) (evals-from? ?x false)))
 (if): Entering (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking 'if' condition (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 (if): Taking 'then' branch of (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 true)
  (if evals-from?): Succeeded (evals-from? true true)
 (if): Succeeded (if (sister laban rebecca) (evals-from? true true) (evals-from? true false))
Recorded answer: true
  1. Backtracking into `sister`/2: (sister laban rebecca)
  1. Failed `sister`/2: (sister laban rebecca)
 (if): Failed (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (sister laban rebecca) (evals-from? ?x true) (evals-from? ?x false)))
[true]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister ?x]
 '((if
    (sister ?sibling ?sister)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
 (if): Entering (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 (if): Taking 'then' branch of (if (sister laban rebecca) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 true)
  (if evals-from?): Succeeded (evals-from? true true)
 (if): Succeeded (if (sister laban rebecca) (evals-from? true true) (evals-from? true false))
Recorded answer: [laban rebecca true]
  1. Backtracking into `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Succeeded `sister`/2: (sister rachel leah)
 (if): Taking 'then' branch of (if (sister rachel leah) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 true)
  (if evals-from?): Succeeded (evals-from? true true)
 (if): Succeeded (if (sister rachel leah) (evals-from? true true) (evals-from? true false))
Recorded answer: [rachel leah true]
  1. Backtracking into `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 (if): Failed (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
[[laban rebecca true] [rachel leah true]]

(do (initialize-prolog))

(query
 '[?sibling ?sister ?x]
 '((if
    (sister ?sibling ?sister)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
 (if): Entering (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  1. Entering `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 (if): Taking 'else' branch of (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 false)
  (if evals-from?): Succeeded (evals-from? false false)
 (if): Succeeded (if (sister ?sibling:0 ?sister:0) (evals-from? false true) (evals-from? false false))
Recorded answer: [?sibling ?sister false]
 (if): Failed (if (sister ?sibling:0 ?sister:0) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
[[?sibling ?sister false]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((first (sister ?sibling ?sister)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((first (sister ?sibling ?sister)))
 (first): Entering first (first (sister ?sibling:0 ?sister:0))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 (first): Succeeded, cutting (first (sister laban rebecca))
Recorded answer: [laban rebecca]
 (first): Failed (first (sister ?sibling:0 ?sister:0))
0. Exhausted query: ((first (sister ?sibling ?sister)))
[[laban rebecca]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister ?x]
 '((if
    (first (sister ?sibling ?sister))
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if (first (sister ?sibling ?sister)) (evals-from? ?x true) (evals-from? ?x false)))
 (if): Entering (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking 'if' condition (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if first): Entering first (first (sister ?sibling:0 ?sister:0))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
  (if first): Succeeded, cutting (first (sister laban rebecca))
 (if): Taking 'then' branch of (if (first (sister laban rebecca)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 true)
  (if evals-from?): Succeeded (evals-from? true true)
 (if): Succeeded (if (first (sister laban rebecca)) (evals-from? true true) (evals-from? true false))
Recorded answer: [laban rebecca true]
  (if first): Failed (first (sister ?sibling:0 ?sister:0))
 (if): Failed (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if (first (sister ?sibling ?sister)) (evals-from? ?x true) (evals-from? ?x false)))
[[laban rebecca true]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((first (and (sister ?sibling ?sister) (sister ?sibling ?sister))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((first (and (sister ?sibling ?sister) (sister ?sibling ?sister))))
 (first): Entering first (first (and (sister ?sibling:0 ?sister:0) (sister ?sibling:0 ?sister:0)))
  (first and): Entering (and (sister ?sibling:0 ?sister:0) (sister ?sibling:0 ?sister:0))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
  (first and): Succeeded (and (sister laban rebecca) (sister laban rebecca))
 (first): Succeeded, cutting (first (and (sister laban rebecca) (sister laban rebecca)))
Recorded answer: [laban rebecca]
 (first): Failed (first (and (sister ?sibling:0 ?sister:0) (sister ?sibling:0 ?sister:0)))
0. Exhausted query: ((first (and (sister ?sibling ?sister) (sister ?sibling ?sister))))
[[laban rebecca]]

(do (initialize-prolog))

(query 'true '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 (var): Entering (var ?x:0)
 (var): Succeeded (var ?x:0)
Recorded answer: true
0. Exhausted query: ((var ?x))
[true]

(do (initialize-prolog))

(query 'true '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 (var): Entering (var ?x:0)
 (var): Succeeded (var ?x:0)
Recorded answer: true
0. Exhausted query: ((var ?x))
[true]

(do (initialize-prolog))

(query '?x '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 (var): Entering (var ?x:0)
 (var): Succeeded (var ?x:0)
Recorded answer: ?x
0. Exhausted query: ((var ?x))
[?x]

(do (initialize-prolog))

(query '?y '(#'?x) :limit nil :discard-subsumed true)

0. Processing query: ((var ?x))
 (var): Entering (var ?x:0)
 (var): Succeeded (var ?x:0)
Recorded answer: ?y
0. Exhausted query: ((var ?x))
[?y]

(do (initialize-prolog))

(query 'true '(#'1) :limit nil :discard-subsumed true)

0. Processing query: ((var 1))
 (var): Entering (var 1)
 (var): Failed (var 1)
0. Exhausted query: ((var 1))
[]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 'true
 '((sister ?_person ?_person))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((sister ?_person ?_person))
 1. Entering `sister`/2: (sister ?_person:0 ?_person:0)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: true
 1. Backtracking into `sister`/2: (sister ?_person:0 ?_person:0)
 1. Succeeded `sister`/2: (sister rachel leah)
Duplicate answer (not recorded): true
 1. Backtracking into `sister`/2: (sister ?_person:0 ?_person:0)
 1. Failed `sister`/2: (sister ?_person:0 ?_person:0)
0. Exhausted query: ((sister ?_person ?_person))
[true]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query 'true '((sister ?_ ?_)) :limit nil :discard-subsumed true)

0. Processing query: ((sister ?_ ?_))
 1. Entering `sister`/2: (sister ?_:0 ?_:0)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: true
 1. Backtracking into `sister`/2: (sister ?_:0 ?_:0)
 1. Succeeded `sister`/2: (sister rachel leah)
Duplicate answer (not recorded): true
 1. Backtracking into `sister`/2: (sister ?_:0 ?_:0)
 1. Failed `sister`/2: (sister ?_:0 ?_:0)
0. Exhausted query: ((sister ?_ ?_))
[true]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query 'true '((sister ? ?)) :limit nil :discard-subsumed true)

0. Processing query: ((sister ? ?))
 1. Entering `sister`/2: (sister ?:0 ?:0)
 1. Matched head (sister laban rebecca): (sister laban rebecca)
 1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: true
 1. Backtracking into `sister`/2: (sister ?:0 ?:0)
 1. Succeeded `sister`/2: (sister rachel leah)
Duplicate answer (not recorded): true
 1. Backtracking into `sister`/2: (sister ?:0 ?:0)
 1. Failed `sister`/2: (sister ?:0 ?:0)
0. Exhausted query: ((sister ? ?))
[true]

(do (initialize-prolog))

(query
 '?x
 '((and
    (if (true) (same ?x :succeed) (same ?x :fail))
    (evals-from? ?x :succeed)
    (false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (if (true) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :succeed) (false)))
 (and): Entering (and (if (true) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :succeed) (false))
  (and if): Entering (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
  (and if): Checking 'if' condition (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
   (and if true): Entering (true)
   (and if true): Succeeded (true)
  (and if): Taking 'then' branch of (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
   (and if same): Entering (same ?x:0 :succeed)
   (and if same): Succeeded (same :succeed :succeed)
  (and if): Succeeded (if (true) (same :succeed :succeed) (same :succeed :fail))
  (and evals-from?): Entering (evals-from? :succeed :succeed)
  (and evals-from?): Succeeded (evals-from? :succeed :succeed)
  (and false): Entering (false)
  (and false): Failed (false)
  (and if): Failed (if (true) (same ?x:0 :succeed) (same ?x:0 :fail))
 (and): Failed (and (if (true) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :succeed) (false))
0. Exhausted query: ((and (if (true) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :succeed) (false)))
[]

(do (initialize-prolog))

(query
 '?x
 '((and
    (if (false) (same ?x :succeed) (same ?x :fail))
    (evals-from? ?x :fail)
    (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (true)))
 (and): Entering (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (true))
  (and if): Entering (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
  (and if): Checking 'if' condition (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   (and if false): Entering (false)
   (and if false): Failed (false)
  (and if): Taking 'else' branch of (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   (and if same): Entering (same ?x:0 :fail)
   (and if same): Succeeded (same :fail :fail)
  (and if): Succeeded (if (false) (same :fail :succeed) (same :fail :fail))
  (and evals-from?): Entering (evals-from? :fail :fail)
  (and evals-from?): Succeeded (evals-from? :fail :fail)
  (and true): Entering (true)
  (and true): Succeeded (true)
 (and): Succeeded (and (if (false) (same :fail :succeed) (same :fail :fail)) (evals-from? :fail :fail) (true))
Recorded answer: :fail
  (and if): Failed (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
 (and): Failed (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (true))
0. Exhausted query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (true)))
[:fail]

(do (initialize-prolog))

(query
 '?x
 '((and
    (if (false) (same ?x :succeed) (same ?x :fail))
    (evals-from? ?x :fail)
    (or (true) (false))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (or (true) (false))))
 (and): Entering (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (or (true) (false)))
  (and if): Entering (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
  (and if): Checking 'if' condition (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   (and if false): Entering (false)
   (and if false): Failed (false)
  (and if): Taking 'else' branch of (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
   (and if same): Entering (same ?x:0 :fail)
   (and if same): Succeeded (same :fail :fail)
  (and if): Succeeded (if (false) (same :fail :succeed) (same :fail :fail))
  (and evals-from?): Entering (evals-from? :fail :fail)
  (and evals-from?): Succeeded (evals-from? :fail :fail)
  (and or): Entering (or (true) (false))
  (and or): Succeeded (or (true) (false))
   (and or true): Entering (true)
   (and or true): Succeeded (true)
 (and): Succeeded (and (if (false) (same :fail :succeed) (same :fail :fail)) (evals-from? :fail :fail) (or (true) (false)))
Recorded answer: :fail
  (and or): Backtracking into (or (true) (false))
   (and or false): Entering (false)
   (and or false): Failed (false)
  (and or): Failed (or (true) (false))
  (and if): Failed (if (false) (same ?x:0 :succeed) (same ?x:0 :fail))
 (and): Failed (and (if (false) (same ?x:0 :succeed) (same ?x:0 :fail)) (evals-from? ?x:0 :fail) (or (true) (false)))
0. Exhausted query: ((and (if (false) (same ?x :succeed) (same ?x :fail)) (evals-from? ?x :fail) (or (true) (false))))
[:fail]

(do (initialize-prolog))

(query
 '?x
 '((and) (evals-from? ?x :fail) (true))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and) (evals-from? ?x :fail) (true))
 (and): Entering (and)
 (and): Succeeded (and)
 (evals-from?): Entering (evals-from? ?x:0 :fail)
 (evals-from?): Succeeded (evals-from? :fail :fail)
 (true): Entering (true)
 (true): Succeeded (true)
Recorded answer: :fail
 (and): Failed (and)
0. Exhausted query: ((and) (evals-from? ?x :fail) (true))
[:fail]

(do (initialize-prolog))

(query
 '?x
 '((and (and) (evals-from? ?x :fail) (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((and (and) (evals-from? ?x :fail) (true)))
 (and): Entering (and (and) (evals-from? ?x:0 :fail) (true))
  (and and): Entering (and)
  (and and): Succeeded (and)
  (and evals-from?): Entering (evals-from? ?x:0 :fail)
  (and evals-from?): Succeeded (evals-from? :fail :fail)
  (and true): Entering (true)
  (and true): Succeeded (true)
 (and): Succeeded (and (and) (evals-from? :fail :fail) (true))
Recorded answer: :fail
  (and and): Failed (and)
 (and): Failed (and (and) (evals-from? ?x:0 :fail) (true))
0. Exhausted query: ((and (and) (evals-from? ?x :fail) (true)))
[:fail]

(do (initialize-prolog))

(query 'true '((cond*)) :limit nil :discard-subsumed true)

0. Processing query: ((cond*))
 (cond*): Applying logic transform (cond*)
 (or): Entering (or)
 (or): Failed (or)
0. Exhausted query: ((cond*))
[]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister ?x]
 '((if%
    (sister ?sibling ?sister)
    (evals-from? ?x true)
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((if% (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
 (if%): Applying logic transform (if% ?if ?then ?else)
 (if): Entering (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
 (if): Checking 'if' condition (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if first): Entering first (first (sister ?sibling:0 ?sister:0))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
  (if first): Succeeded, cutting (first (sister laban rebecca))
 (if): Taking 'then' branch of (if (first (sister laban rebecca)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
  (if evals-from?): Entering (evals-from? ?x:0 true)
  (if evals-from?): Succeeded (evals-from? true true)
 (if): Succeeded (if (first (sister laban rebecca)) (evals-from? true true) (evals-from? true false))
Recorded answer: [laban rebecca true]
  (if first): Failed (first (sister ?sibling:0 ?sister:0))
 (if): Failed (if (first (sister ?sibling:0 ?sister:0)) (evals-from? ?x:0 true) (evals-from? ?x:0 false))
0. Exhausted query: ((if% (sister ?sibling ?sister) (evals-from? ?x true) (evals-from? ?x false)))
[[laban rebecca true]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?x]
 '((cond%
    (sister ?sibling adam)
    (evals-from? ?x 'adam)
    (sister ?sibling eve)
    (evals-from? ?x 'eve)
    :else
    (evals-from? ?x false)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((cond% (sister ?sibling adam) (evals-from? ?x (quote adam)) (sister ?sibling eve) (evals-from? ?x (quote eve)) :else (evals-from? ?x false)))
 (cond%): Applying logic transform (cond% ?if1 ?then1 ?if2 ?then2 ?rest)
 (if%): Applying logic transform (if% ?if ?then ?else)
 (if): Entering (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
 (if): Checking 'if' condition (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
  (if first): Entering first (first (sister ?sibling:0 adam))
   1. Entering `sister`/2: (sister ?sibling:0 adam)
   1. Failed `sister`/2: (sister ?sibling:0 adam)
  (if first): Failed (first (sister ?sibling:0 adam))
 (if): Taking 'else' branch of (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
  (if cond%): Applying logic transform (cond% ?if ?then :else ?else)
  (if if%): Applying logic transform (if% ?if ?then ?else)
  (if if): Entering (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
  (if if): Checking 'if' condition (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
   (if if first): Entering first (first (sister ?sibling:0 eve))
    1. Entering `sister`/2: (sister ?sibling:0 eve)
    1. Failed `sister`/2: (sister ?sibling:0 eve)
   (if if first): Failed (first (sister ?sibling:0 eve))
  (if if): Taking 'else' branch of (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
   (if if evals-from?): Entering (evals-from? ?x:0 false)
   (if if evals-from?): Succeeded (evals-from? false false)
  (if if): Succeeded (if (first (sister ?sibling:0 eve)) (evals-from? false (quote eve)) (evals-from? false false))
 (if): Succeeded (if (first (sister ?sibling:0 adam)) (evals-from? false (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? false (quote eve)) :else (evals-from? false false)))
Recorded answer: [?sibling false]
  (if if): Failed (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
 (if): Failed (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
0. Exhausted query: ((cond% (sister ?sibling adam) (evals-from? ?x (quote adam)) (sister ?sibling eve) (evals-from? ?x (quote eve)) :else (evals-from? ?x false)))
[[?sibling false]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((or (sister ?sibling ?sister) (true)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((or (sister ?sibling ?sister) (true)))
 (or): Entering (or (sister ?sibling:0 ?sister:0) (true))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
Recorded answer: [laban rebecca]
  1. Backtracking into `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Succeeded `sister`/2: (sister rachel leah)
Recorded answer: [rachel leah]
  1. Backtracking into `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 (or): Backtracking into (or (sister ?sibling:0 ?sister:0) (true))
  (or true): Entering (true)
  (or true): Succeeded (true)
Recorded subsuming answer (discarded 2 subsumed answer(s)):  [?sibling ?sister]
 (or): Failed (or (sister ?sibling:0 ?sister:0) (true))
0. Exhausted query: ((or (sister ?sibling ?sister) (true)))
[[?sibling ?sister]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((first (or (sister ?sibling ?sister) (true))))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((first (or (sister ?sibling ?sister) (true))))
 (first): Entering first (first (or (sister ?sibling:0 ?sister:0) (true)))
  (first or): Entering (or (sister ?sibling:0 ?sister:0) (true))
  (first or): Succeeded (or (sister ?sibling:0 ?sister:0) (true))
   1. Entering `sister`/2: (sister laban rebecca)
   1. Matched head (sister laban rebecca): (sister laban rebecca)
   1. Succeeded `sister`/2: (sister laban rebecca)
 (first): Succeeded, cutting (first (or (sister laban rebecca) (true)))
Recorded answer: [laban rebecca]
 (first): Failed (first (or (sister ?sibling:0 ?sister:0) (true)))
0. Exhausted query: ((first (or (sister ?sibling ?sister) (true))))
[[laban rebecca]]

(do
 (initialize-prolog)
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah))))

(query
 '[?sibling ?sister]
 '((optional (sister ?sibling ?sister)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((optional (sister ?sibling ?sister)))
 (optional): Applying logic transform (optional ?goal)
 (if): Entering (if (sister ?sibling:0 ?sister:0) (true) (true))
 (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (true) (true))
  1. Entering `sister`/2: (sister laban rebecca)
  1. Matched head (sister laban rebecca): (sister laban rebecca)
  1. Succeeded `sister`/2: (sister laban rebecca)
 (if): Taking 'then' branch of (if (sister laban rebecca) (true) (true))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Succeeded (if (sister laban rebecca) (true) (true))
Recorded answer: [laban rebecca]
  1. Backtracking into `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Succeeded `sister`/2: (sister rachel leah)
 (if): Taking 'then' branch of (if (sister rachel leah) (true) (true))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Succeeded (if (sister rachel leah) (true) (true))
Recorded answer: [rachel leah]
  1. Backtracking into `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 (if): Failed (if (sister ?sibling:0 ?sister:0) (true) (true))
0. Exhausted query: ((optional (sister ?sibling ?sister)))
[[laban rebecca] [rachel leah]]

(do
 (initialize-prolog)
 (assert<- '((if% ?if ?then ?else) (if (first ?if) ?then ?else)))
 (assert<- '((cond*) (or)))
 (assert<- '((cond* ?if ?then :else ?else) (if* ?if ?then ?else)))
 (assert<-
  '((cond* ?if1 ?then1 ?if2 ?then2 & ?rest)
    (if* ?if1 ?then1 (cond* ?if2 ?then2 & ?rest))))
 (assert<- '((lisp ?form) (do ?form)))
 (assert<- '((lisp ?logic ?form) (evals-from? ?logic ?form)))
 (assert<- '((is ?a ?b) (same ?a ?b)))
 (assert<- '((if* ?if ?then ?else) (if ?if ?then ?else)))
 (assert<- '((sister laban rebecca)))
 (assert<- '((sister rachel leah)))
 (assert<- '((different ?a ?b) (not (same ?a ?b))))
 (assert<- '((cond%) (or)))
 (assert<- '((cond% ?if ?then :else ?else) (if% ?if ?then ?else)))
 (assert<-
  '((cond% ?if1 ?then1 ?if2 ?then2 & ?rest)
    (if% ?if1 ?then1 (cond% ?if2 ?then2 & ?rest))))
 (assert<- '((lispp ?form) (truthy? ?form)))
 (assert<- '((optional ?goal) (if ?goal (true) (true)))))

(query
 '[?sibling ?x]
 '((cond%
    (sister ?sibling adam)
    (evals-from? ?x 'adam)
    (sister ?sibling eve)
    (evals-from? ?x 'eve)
    :else
    (evals-from? ?x false)))
 :limit
 1
 :discard-subsumed
 true)

0. Processing query: ((cond% (sister ?sibling adam) (evals-from? ?x (quote adam)) (sister ?sibling eve) (evals-from? ?x (quote eve)) :else (evals-from? ?x false)))
 1. Entering `cond%`/6: (cond% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
 1. Matched head (cond% ?if1:1 ?then1:1 ?if2:1 ?then2:1 & ?rest:1): (cond% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
  2. Entering `if%`/3: (if% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
  2. Matched head (if% ?if:2 ?then:2 ?else:2): (if% (sister ?sibling:0 adam) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
   (if): Entering (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
   (if): Checking 'if' condition (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
    (if first): Entering first (first (sister ?sibling:0 adam))
     3. Entering `sister`/2: (sister ?sibling:0 adam)
     3. Failed `sister`/2: (sister ?sibling:0 adam)
    (if first): Failed (first (sister ?sibling:0 adam))
   (if): Taking 'else' branch of (if (first (sister ?sibling:0 adam)) (evals-from? ?x:0 (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false)))
    3. Entering `cond%`/4: (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
    3. Matched head (cond% ?if:3 ?then:3 :else ?else:3): (cond% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) :else (evals-from? ?x:0 false))
     4. Entering `if%`/3: (if% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
     4. Matched head (if% ?if:4 ?then:4 ?else:4): (if% (sister ?sibling:0 eve) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
      (if if): Entering (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
      (if if): Checking 'if' condition (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
       (if if first): Entering first (first (sister ?sibling:0 eve))
        5. Entering `sister`/2: (sister ?sibling:0 eve)
        5. Failed `sister`/2: (sister ?sibling:0 eve)
       (if if first): Failed (first (sister ?sibling:0 eve))
      (if if): Taking 'else' branch of (if (first (sister ?sibling:0 eve)) (evals-from? ?x:0 (quote eve)) (evals-from? ?x:0 false))
       (if if evals-from?): Entering (evals-from? ?x:0 false)
       (if if evals-from?): Succeeded (evals-from? false false)
      (if if): Succeeded (if (first (sister ?sibling:0 eve)) (evals-from? false (quote eve)) (evals-from? false false))
     (if): Succeeded (if (first (sister ?sibling:0 adam)) (evals-from? false (quote adam)) (cond% (sister ?sibling:0 eve) (evals-from? false (quote eve)) :else (evals-from? false false)))
Recorded answer: [?sibling false]
Answer limit reached.
[[?sibling false]]

(do (initialize-prolog))

(query 'true '((ground [a b])) :limit nil :discard-subsumed true)

0. Processing query: ((ground [a b]))
 (ground): Entering (ground [a b])
 (ground): Succeeded (ground [a b])
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((ground [a b])) :limit nil :discard-subsumed true)

0. Processing query: ((ground [a b]))
 (ground): Entering (ground [a b])
 (ground): Succeeded (ground [a b])
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((ground ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((ground ?x))
 (ground): Entering (ground ?x:0)
 (ground): Failed (ground ?x:0)
0. Exhausted query: ((ground ?x))
[]

(do (initialize-prolog))

(query '?x '((same ?x 1) (ground ?x)) :limit nil :discard-subsumed true)

0. Processing query: ((same ?x 1) (ground ?x))
 (same): Entering (same ?x:0 1)
 (same): Succeeded (same 1 1)
 (ground): Entering (ground 1)
 (ground): Succeeded (ground 1)
Recorded answer: 1
0. Exhausted query: ((same ?x 1) (ground ?x))
[1]

(do (initialize-prolog))

(query
 '[?sibling ?sister]
 '((optional (sister ?sibling ?sister)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((optional (sister ?sibling ?sister)))
 (optional): Applying logic transform (optional ?goal)
 (if): Entering (if (sister ?sibling:0 ?sister:0) (true) (true))
 (if): Checking 'if' condition (if (sister ?sibling:0 ?sister:0) (true) (true))
  1. Entering `sister`/2: (sister ?sibling:0 ?sister:0)
  1. Failed `sister`/2: (sister ?sibling:0 ?sister:0)
 (if): Taking 'else' branch of (if (sister ?sibling:0 ?sister:0) (true) (true))
  (if true): Entering (true)
  (if true): Succeeded (true)
 (if): Succeeded (if (sister ?sibling:0 ?sister:0) (true) (true))
Recorded answer: [?sibling ?sister]
 (if): Failed (if (sister ?sibling:0 ?sister:0) (true) (true))
0. Exhausted query: ((optional (sister ?sibling ?sister)))
[[?sibling ?sister]]

(do (initialize-prolog))

(query 'true '((different 1 2)) :limit nil :discard-subsumed true)

0. Processing query: ((different 1 2))
 (different): Applying logic transform (different ?a ?b)
 (not): Entering (not (same 1 2))
  (not same): Entering (same 1 2)
  (not same): Failed (same 1 2)
 (not): Succeeded (not (same 1 2))
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query 'true '((different 2 2)) :limit nil :discard-subsumed true)

0. Processing query: ((different 2 2))
 (different): Applying logic transform (different ?a ?b)
 (not): Entering (not (same 2 2))
  (not same): Entering (same 2 2)
  (not same): Succeeded (same 2 2)
Recorded answer: true
Answer limit reached.
 (not): Failed (not (same 2 2))
0. Exhausted query: ((different 2 2))
[]

(do (initialize-prolog))

(query
 'true
 '((same (->? (+ 0 1)) 1))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same (->? (+ 0 1)) 1))
 Applied ->? transform
 (evals-from?): Entering (evals-from? ??-0:0 (+ 0 1))
 (evals-from?): Succeeded (evals-from? 1 (+ 0 1))
 (same): Entering (same 1 1)
 (same): Succeeded (same 1 1)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog))

(query
 '[1 2 & ?rest]
 '((same ?rest [3 4]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((same ?rest [3 4]))
 (same): Entering (same ?rest:0 [3 4])
 (same): Succeeded (same [3 4] [3 4])
Recorded answer: [1 2 3 4]
0. Exhausted query: ((same ?rest [3 4]))
[[1 2 3 4]]

(do
 (initialize-prolog)
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query '?rest '((variadic & ?rest)) :limit nil :discard-subsumed true)

0. Processing query: ((variadic & ?rest))
 1. Entering `variadic`/1: (variadic 1)
 1. Matched head (variadic 1): (variadic 1)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (1)
 1. Backtracking into `variadic`/2: (variadic & ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (1 2)
 1. Backtracking into `variadic`/2: (variadic & ?rest:0)
 1. Failed `variadic`/2: (variadic & ?rest:0)
0. Exhausted query: ((variadic & ?rest))
[(1) (1 2)]

(do
 (initialize-prolog)
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query
 '(variadic & ?rest)
 '((variadic & ?rest))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic & ?rest))
 1. Entering `variadic`/1: (variadic 1)
 1. Matched head (variadic 1): (variadic 1)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (variadic 1)
 1. Backtracking into `variadic`/2: (variadic & ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (variadic 1 2)
 1. Backtracking into `variadic`/2: (variadic & ?rest:0)
 1. Failed `variadic`/2: (variadic & ?rest:0)
0. Exhausted query: ((variadic & ?rest))
[(variadic 1) (variadic 1 2)]

(do
 (initialize-prolog)
 (assert<- '((variadic-term [1])))
 (assert<- '((variadic-term [1 2]))))

(query
 '?rest
 '((variadic-term [& ?rest]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic-term [& ?rest]))
 1. Entering `variadic-term`/1: (variadic-term [1])
 1. Matched head (variadic-term [1]): (variadic-term [1])
 1. Succeeded `variadic-term`/1: (variadic-term [1])
Recorded answer: [1]
 1. Backtracking into `variadic-term`/1: (variadic-term [& ?rest:0])
 1. Succeeded `variadic-term`/1: (variadic-term [1 2])
Recorded answer: [1 2]
 1. Backtracking into `variadic-term`/1: (variadic-term [& ?rest:0])
 1. Failed `variadic-term`/1: (variadic-term [& ?rest:0])
0. Exhausted query: ((variadic-term [& ?rest]))
[[1] [1 2]]

(do
 (initialize-prolog)
 (assert<- '((variadic-term [1])))
 (assert<- '((variadic-term [1 2]))))

(query
 '?rest
 '((variadic-term [1 & ?rest]))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic-term [1 & ?rest]))
 1. Entering `variadic-term`/1: (variadic-term [1])
 1. Matched head (variadic-term [1]): (variadic-term [1])
 1. Succeeded `variadic-term`/1: (variadic-term [1])
Recorded answer: []
 1. Backtracking into `variadic-term`/1: (variadic-term [1 & ?rest:0])
 1. Succeeded `variadic-term`/1: (variadic-term [1 2])
Recorded answer: [2]
 1. Backtracking into `variadic-term`/1: (variadic-term [1 & ?rest:0])
 1. Failed `variadic-term`/1: (variadic-term [1 & ?rest:0])
0. Exhausted query: ((variadic-term [1 & ?rest]))
[[] [2]]

(do
 (initialize-prolog)
 (assert<- '((variadic-term [1])))
 (assert<- '((variadic-term [1 2]))))

(query
 '?rest
 '((variadic-term (& ?rest)))
 :limit
 nil
 :discard-subsumed
 true)

0. Processing query: ((variadic-term (& ?rest)))
 1. Entering `variadic-term`/1: (variadic-term (& ?rest:0))
 1. Failed `variadic-term`/1: (variadic-term (& ?rest:0))
0. Exhausted query: ((variadic-term (& ?rest)))
[]

(do
 (initialize-prolog)
 (assert<- '((variadic)))
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query '?rest '((variadic & ?rest)) :limit nil :discard-subsumed true)

0. Processing query: ((variadic & ?rest))
 1. Entering `variadic`/0: (variadic)
 1. Matched head (variadic): (variadic)
 1. Succeeded `variadic`/0: (variadic)
Recorded answer: ()
 1. Backtracking into `variadic`/2: (variadic & ?rest:0)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (1)
 1. Backtracking into `variadic`/2: (variadic & ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (1 2)
 1. Backtracking into `variadic`/2: (variadic & ?rest:0)
 1. Failed `variadic`/2: (variadic & ?rest:0)
0. Exhausted query: ((variadic & ?rest))
[() (1) (1 2)]

(do
 (initialize-prolog)
 (assert<- '((variadic)))
 (assert<- '((variadic 1)))
 (assert<- '((variadic 1 2))))

(query '?rest '((& ?rest)) :limit nil :discard-subsumed true)

0. Processing query: ((& ?rest))
 1. Entering `variadic`/0: (variadic)
 1. Matched head (variadic): (variadic)
 1. Succeeded `variadic`/0: (variadic)
Recorded answer: (variadic)
 1. Backtracking into `&`/1: (& ?rest:0)
 1. Succeeded `variadic`/1: (variadic 1)
Recorded answer: (variadic 1)
 1. Backtracking into `&`/1: (& ?rest:0)
 1. Succeeded `variadic`/2: (variadic 1 2)
Recorded answer: (variadic 1 2)
 1. Backtracking into `&`/1: (& ?rest:0)
 1. Failed `&`/1: (& ?rest:0)
0. Exhausted query: ((& ?rest))
[(variadic) (variadic 1) (variadic 1 2)]

(do (initialize-prolog) (assert<- '((variadic & ?rest))))

(query 'true '((variadic 1)) :limit nil :discard-subsumed true)

0. Processing query: ((variadic 1))
 1. Entering `variadic`/1: (variadic 1)
 1. Matched head (variadic & ?rest:1): (variadic 1)
 1. Succeeded `variadic`/2: (variadic 1)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '(([complex] 1))))

(query '?x '(([complex] ?x)) :limit nil :discard-subsumed true)

0. Processing query: (([complex] ?x))
 1. Entering `[complex]`/1: ([complex] 1)
 1. Matched head ([complex] 1): ([complex] 1)
 1. Succeeded `[complex]`/1: ([complex] 1)
Recorded answer: 1
 1. Backtracking into `[complex]`/1: ([complex] ?x:0)
 1. Failed `[complex]`/1: ([complex] ?x:0)
0. Exhausted query: (([complex] ?x))
[1]

(do (initialize-prolog) (assert<- '(([complex 1] 1))))

(query '?x '(([complex ?x] ?x)) :limit nil :discard-subsumed true)

0. Processing query: (([complex ?x] ?x))
 1. Entering `[complex 1]`/1: ([complex 1] 1)
 1. Matched head ([complex 1] 1): ([complex 1] 1)
 1. Succeeded `[complex 1]`/1: ([complex 1] 1)
Recorded answer: 1
 1. Backtracking into `[complex ?x:0]`/1: ([complex ?x:0] ?x:0)
 1. Failed `[complex ?x:0]`/1: ([complex ?x:0] ?x:0)
0. Exhausted query: (([complex ?x] ?x))
[1]

(do (initialize-prolog) (assert<- '(([complex ?x] ?x))))

(query 'true '(([complex 1] 1)) :limit nil :discard-subsumed true)

0. Processing query: (([complex 1] 1))
 1. Entering `[complex 1]`/1: ([complex 1] 1)
 1. Matched head ([complex ?x:1] ?x:1): ([complex 1] 1)
 1. Succeeded `[complex ?x:1]`/1: ([complex 1] 1)
Recorded answer: true
Answer limit reached.
[true]

(do (initialize-prolog) (assert<- '(([complex & ?rest] ?rest))))

(query 'true '(([complex 1] (1))) :limit nil :discard-subsumed true)

0. Processing query: (([complex 1] (1)))
 1. Entering `[complex 1]`/1: ([complex 1] (1))
 1. Matched head ([complex & ?rest:1] ?rest:1): ([complex 1] [1])
 1. Succeeded `[complex & ?rest:1]`/1: ([complex 1] [1])
Recorded answer: true
Answer limit reached.
[true]
